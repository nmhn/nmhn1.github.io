{
    "version": "https://jsonfeed.org/version/1",
    "title": "年没怀念der博客",
    "subtitle": "",
    "icon": "http://example.com/images/favicon.ico",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/04/02/202242%20%E5%AD%97%E8%8A%82%E4%BA%8C%E9%9D%A2%E8%AE%B0%E5%BD%95/",
            "url": "http://example.com/2022/04/02/202242%20%E5%AD%97%E8%8A%82%E4%BA%8C%E9%9D%A2%E8%AE%B0%E5%BD%95/",
            "title": "字节二面记录",
            "date_published": "2022-04-02T12:01:01.000Z",
            "content_html": "<h1 id=\"202242-字节二面记录\"><a class=\"anchor\" href=\"#202242-字节二面记录\">#</a> 2022/4/2 字节二面记录</h1>\n<blockquote>\n<p>啸问题：开头以为只有暑假可以实习，直接被面试官拒了，然后被同学提醒才发现开学也能实习，紧急联系回来了</p>\n<p>面试官还挺好的，居然还能继续面</p>\n</blockquote>\n<h2 id=\"问了些啥\"><a class=\"anchor\" href=\"#问了些啥\">#</a> 问了些啥</h2>\n<p>最开始还是最难顶的自我介绍，感觉像是一个垃圾桶被要求介绍自己 (x), 我下次应该记住重复一下北理是个 985, 不然听起来像个野鸡大学 (</p>\n<p>和一面不同的是，这回自我介绍完了就开始做题，还问了 python 里头元组和字典的关系 (答不出来，寄)</p>\n<p>计网方面问了 http 请求一个页面的过程 (上学期刚上完这学期就忘得差不多了属于是)</p>\n<p>这回没问数据库，不知道是为啥</p>\n<p>问了对软件项目管理的理解 (?), 我就当问我管理上的看法，感觉有点答非所问</p>\n<h2 id=\"哪里不行\"><a class=\"anchor\" href=\"#哪里不行\">#</a> 哪里不行</h2>\n<p>对语言的理解比较烂，属于是只知道用不知道学</p>\n<p>计网还是得看看 http 请求的全过程</p>\n<p>其实数据库查询语句还有点欠缺，不过能用</p>\n",
            "tags": [
                "面试"
            ]
        },
        {
            "id": "http://example.com/2022/04/02/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/",
            "url": "http://example.com/2022/04/02/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/",
            "title": "更新日志",
            "date_published": "2022-04-02T12:00:01.000Z",
            "content_html": "<h3 id=\"202242\"><a class=\"anchor\" href=\"#202242\">#</a> 2022/4/2</h3>\n<blockquote>\n<p>增加了一份面试记录</p>\n</blockquote>\n<h3 id=\"2022316\"><a class=\"anchor\" href=\"#2022316\">#</a> 2022/3/16</h3>\n<blockquote>\n<p>更新新学期内容和部分学习内容（REACT）</p>\n</blockquote>\n<h3 id=\"2021126\"><a class=\"anchor\" href=\"#2021126\">#</a> 2021/12/6</h3>\n<blockquote>\n<p>创建站</p>\n<p>链接评论服务</p>\n<p>更新域名 <span class=\"exturl\" data-url=\"aHR0cDovL25pYW5tZWlodWFpbmlhbi5jb20=\">nianmeihuainian.com</span></p>\n<p>更改主题</p>\n</blockquote>\n<h3 id=\"2021127\"><a class=\"anchor\" href=\"#2021127\">#</a> 2021/12/7</h3>\n<blockquote>\n<p>评论区恢复</p>\n<p>修改打赏图</p>\n<p>修改主题图片</p>\n<p>修复搜索功能</p>\n</blockquote>\n",
            "tags": [
                "log"
            ]
        },
        {
            "id": "http://example.com/2022/03/16/React%E5%AD%A6%E4%B9%A020220314%20SetState/",
            "url": "http://example.com/2022/03/16/React%E5%AD%A6%E4%B9%A020220314%20SetState/",
            "title": "React学习20220314 SetState",
            "date_published": "2022-03-16T03:48:15.000Z",
            "content_html": "<h1 id=\"react学习20220314-setstate\"><a class=\"anchor\" href=\"#react学习20220314-setstate\">#</a> React 学习 20220314 SetState</h1>\n<h2 id=\"初始认知\"><a class=\"anchor\" href=\"#初始认知\">#</a> 初始认知</h2>\n<p>setState 之后立马访问对应 state，会发现它并没有改变，而是会在之后某个时间发生变化</p>\n<h2 id=\"异步的动机和原理\"><a class=\"anchor\" href=\"#异步的动机和原理\">#</a> 异步的动机和原理</h2>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMC5sZ3N0YXRpYy5jb20vaS9pbWFnZS9NMDAvNkQvOEEvQ2lxYzFGLXVNZVNBWUs2RkFBQk4wVnducTVNODE0LnBuZw==\">https://s0.lgstatic.com/i/image/M00/6D/8A/Ciqc1F-uMeSAYK6FAABN0Vwnq5M814.png</span>&quot;alt=&quot; 图片 3.png&quot;data-nodeid=&quot;13893&quot;&gt;</p>\n<h2 id=\"异步避免重复rerender\"><a class=\"anchor\" href=\"#异步避免重复rerender\">#</a> 异步避免重复 reRender</h2>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/typoimg/image-20220314185248371.png\" alt=\"image-20220314185248371\" /></p>\n<h2 id=\"从源码角度看异步setstate\"><a class=\"anchor\" href=\"#从源码角度看异步setstate\">#</a> 从源码角度看异步 setState</h2>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/typoimg/image-20220314185446537.png\" alt=\"image-20220314185446537\" /></p>\n<h2 id=\"再查看batchingstrategy\"><a class=\"anchor\" href=\"#再查看batchingstrategy\">#</a> 再查看 batchingStrategy</h2>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/typoimg/image-20220314185810854.png\" alt=\"image-20220314185810854\" /></p>\n<h2 id=\"理解transaction事务机制\"><a class=\"anchor\" href=\"#理解transaction事务机制\">#</a> 理解 Transaction（事务）机制</h2>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/typoimg/image-20220314185913490.png\" alt=\"image-20220314185913490\" /></p>\n<h2 id=\"同步现象的本质\"><a class=\"anchor\" href=\"#同步现象的本质\">#</a> 同步现象的本质</h2>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/typoimg/image-20220314190033221.png\" alt=\"image-20220314190033221\" /></p>\n",
            "tags": [
                "React"
            ]
        },
        {
            "id": "http://example.com/2022/03/16/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/",
            "url": "http://example.com/2022/03/16/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/",
            "title": "React学习20220314 虚拟DOM",
            "date_published": "2022-03-16T03:48:15.000Z",
            "content_html": "<h1 id=\"react学习20220314-虚拟dom\"><a class=\"anchor\" href=\"#react学习20220314-虚拟dom\">#</a> React 学习 20220314 虚拟 DOM</h1>\n<h2 id=\"虚拟dom是什么\"><a class=\"anchor\" href=\"#虚拟dom是什么\">#</a> 虚拟 DOM 是什么</h2>\n<p>是 JS 和 DOM 之间的一个映射缓存，在形态上表现为一个能够描述 DOM 结构及其属性信息的 JS 对象。</p>\n<p>在 REACT 中，表现为</p>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314142105501.png\" alt=\"image-20220314142105501\" /></p>\n<p>是 JS 对象，是对真实 DOM 的描述</p>\n<h2 id=\"如何工作\"><a class=\"anchor\" href=\"#如何工作\">#</a> 如何工作</h2>\n<blockquote>\n<ul>\n<li>挂载阶段：结合 JSX 的描述，构建出虚拟 DOM 树，然后通过 ReactDOM.render 实现虚拟 DOM 到真实 DOM 的映射</li>\n<li>更新阶段，页面的变化在作用于真实 DOM 之前，先作用于虚拟 DOM，虚拟 DOM 在 JS 层借助算法先对比出那些真实 DOM 需要被改变，然后将改变作用于真实 DOM</li>\n</ul>\n</blockquote>\n<p>这一段历史讲得好有趣，摘下来</p>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314142856250.png\" alt=\"image-20220314142856250\" /></p>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314145559439.png\" alt=\"image-20220314145559439\" /></p>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314145616729.png\" alt=\"image-20220314145616729\" /></p>\n<p>&lt;p data-nodeid=&quot;6717&quot;&gt; 可以看出，模板语法其实就是把 JS 和 HTML 结合在一起的一种规则，而模板引擎做的事情也非常容易理解。&lt;/p&gt;<br />\n&lt;p data-nodeid=&quot;6718&quot;&gt; 把 staff 这个数据源读进去，塞到预置好的 HTML 模板里，然后把两者融合在一起，吐出一段目标字符串给你。这段字符串的内容，其实就是一份标准的、可用于渲染的 HTML 代码，它将对应一个 DOM 元素。最后，将这个 DOM 元素挂载到页面中去，整个模板的渲染流程也就走完了。&lt;/p&gt;<br />\n&lt;p data-nodeid=&quot;6719&quot;&gt; 这个过程可以用伪代码来表示，如下所示：&lt;/p&gt;<br />\n&lt;pre class=&quot;lang-js&quot; data-nodeid=&quot;6720&quot;&gt;&lt;code data-language=&quot;js&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 数据和模板融合出 HTML 代码 &lt;/span&gt;<br />\n&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; targetDOM = template({&lt;span class=&quot;hljs-attr&quot;&gt;data&lt;/span&gt;: students})<br />\n&lt;span class=&quot;hljs-comment&quot;&gt;// 添加到页面中去 &lt;/span&gt;<br />\n&lt;span class=&quot;hljs-built_in&quot;&gt;document&lt;/span&gt;.body.appendChild(targetDOM)<br />\n&lt;/code&gt;&lt;/pre&gt;<br />\n&lt;p data-nodeid=&quot;6721&quot;&gt; 当然，实际的过程会比我们描述的要复杂一些。这里我补充一下模板引擎的实现思路，供感兴趣的同学参考。模板引擎一般需要做下面几件事情：&lt;/p&gt;<br />\n&lt;ol data-nodeid=&quot;6722&quot;&gt;<br />\n&lt;li data-nodeid=&quot;6723&quot;&gt;<br />\n&lt;p data-nodeid=&quot;6724&quot;&gt; 读取 HTML 模板并解析它，分离出其中的 JS 信息；&lt;/p&gt;<br />\n&lt;/li&gt;<br />\n&lt;li data-nodeid=&quot;6725&quot;&gt;<br />\n&lt;p data-nodeid=&quot;6726&quot;&gt; 将解析出的内容拼接成字符串，动态生成 JS 代码；&lt;/p&gt;<br />\n&lt;/li&gt;<br />\n&lt;li data-nodeid=&quot;6727&quot;&gt;<br />\n&lt;p data-nodeid=&quot;6728&quot;&gt; 运行动态生成的 JS 代码，吐出 “目标 HTML”；&lt;/p&gt;<br />\n&lt;/li&gt;<br />\n&lt;li data-nodeid=&quot;6729&quot;&gt;<br />\n&lt;p data-nodeid=&quot;6730&quot;&gt; 将 “目标 HTML” 赋值给 innerHTML，触发渲染流水线，完成真实 DOM 的渲染。&lt;/p&gt;<br />\n&lt;/li&gt;<br />\n&lt;/ol&gt;<br />\n&lt;p data-nodeid=&quot;6731&quot;&gt; 使用模板引擎方案来渲染数据是非常爽的：每次数据发生变化时，我们都不用关心到底是哪里的数据变了，也不用手动去点对点完成 DOM 的修改。只 &lt; strong data-nodeid=&quot;6882&quot;&gt; 需要关注的仅仅是数据和数据变化本身 &lt;/strong&gt;，DOM 层面的改变模板引擎会帮我们做掉。&lt;/p&gt;<br />\n&lt;p data-nodeid=&quot;6732&quot;&gt; 如此看来，模板引擎像极了一个只需要接收命令，就能够把活干得漂漂亮亮的 “扫地机器人”！可惜的是，模板引擎出现的契机虽然是为了使用户界面与业务数据相分离，但实际的应用场景基本局限在 “实现高效的字符串拼接” 这一个点上，因此不能指望它去做太复杂的事情。尤其令人无法接受的是，&lt;strong data-nodeid=&quot;6888&quot;&gt; 它在性能上的表现并不尽如人意 &lt;/strong&gt;：由于不够 “智能”，它更新 DOM 的方式是将已经渲染出 DOM 整体注销后再整体重渲染，并且不存在更新缓冲这一说。在 DOM 操作频繁的场景下，模板引擎可能会直接导致页面卡死。&lt;/p&gt;<br />\n&lt;blockquote data-nodeid=&quot;6733&quot;&gt;<br />\n&lt;p data-nodeid=&quot;6734&quot;&gt; 注：请注意小标题中 “早期” 这个限定词 —— 本课时所讨论的 “模板引擎” 概念，指的是虚拟 DOM 思想推而广之以前，相对原始的一类模板引擎，这类模板引擎曾经主导了一个时代。但时下来看，越来越多的模板引擎正在引入虚拟 DOM，模板引擎最终也将走向现代化。&lt;/p&gt;<br />\n&lt;/blockquote&gt;<br />\n&lt;p data-nodeid=&quot;6735&quot;&gt; 虽然指望模板引擎实现生产力解放有些天方夜谭，但模板引擎在思想上无疑具备高度的先进性：允许程序员只关心数据而不必关心 DOM 细节的这一操作，和 React 的 “数据驱动视图” 思想如出一辙，实在是高！&lt;/p&gt;<br />\n&lt;h3 data-nodeid=&quot;6736&quot;&gt; 那该怎么办呢？&lt;/h3&gt;<br />\n&lt;p data-nodeid=&quot;6737&quot;&gt;jQuery 救不了加班写 DOM 操作的前端，模板引擎也救不了，那该怎么办呢？&lt;/p&gt;<br />\n&lt;p data-nodeid=&quot;6738&quot;&gt; 这时候有一批仁人志士，兴许是从模板引擎的设计思想上得到了启发，他们明确了要走 “数据驱动视图” 这条基本道路，于是便沿着这个思路往下摸索：模板引擎的数据驱动视图方案，核心问题在于对真实 DOM 的修改过于 “大刀阔斧”，导致了 DOM 操作的范围过大、频率过高，进而可能会导致糟糕的性能。然后这帮人就想啊：既然操作真实 DOM 对性能损耗这么大，那我操作假的 DOM 不就行了？&lt;/p&gt;<br />\n&lt;p data-nodeid=&quot;6739&quot;&gt; 沿着这个思路再往下走，就有了我们都爱的虚拟 DOM。&lt;/p&gt;<br />\n&lt;blockquote data-nodeid=&quot;6740&quot;&gt;<br />\n&lt;p data-nodeid=&quot;6741&quot;&gt; 注：出于严谨，还是要解释下。真实历史中的虚拟 DOM 创作过程，到底有没有向模板引擎去学习，这个暂时无从考证。但是按照前端发展的过程来看，模板引擎和虚拟 DOM 确实在思想上存在递进关系，很多场景下，面试官也可能会问及两者的关系。因此在此处，我采取了这样一种表述方式，希望能够帮助你更好地把握住问题的关键所在。&lt;/p&gt;<br />\n&lt;/blockquote&gt;</p>\n<p>虚拟 DOM 使得之前的全局刷新，改成了有更新的部分更新，在真实 DOM 前加了一层</p>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314151706530.png\" alt=\"image-20220314151706530\" /></p>\n<p>虚拟 DOM 解决的问题重心不是性能</p>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314151854443.png\" alt=\"image-20220314151854443\" /></p>\n<h1 id=\"reconciliation过程与diff算法\"><a class=\"anchor\" href=\"#reconciliation过程与diff算法\">#</a> Reconciliation 过程与 Diff 算法</h1>\n<h2 id=\"diff算法\"><a class=\"anchor\" href=\"#diff算法\">#</a> Diff 算法</h2>\n<p>找两个树结构之间的不同</p>\n<h3 id=\"两个规律\"><a class=\"anchor\" href=\"#两个规律\">#</a> 两个规律</h3>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314152249841.png\" alt=\"image-20220314152249841\" /></p>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314153544145.png\" alt=\"image-20220314153544145\" /></p>\n<p>对于 Key，下图可以比较好地展示使用了 Key 后的更新策略</p>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220314%20%E8%99%9A%E6%8B%9FDOM/assets/image-20220314153745501.png\" alt=\"image-20220314153745501\" /></p>\n<p>如果不使用 key，则仅有 AB 可保留，其他均被重建</p>\n",
            "tags": [
                "React"
            ]
        },
        {
            "id": "http://example.com/2022/03/13/React%E5%AD%A6%E4%B9%A020220313%20Hook/",
            "url": "http://example.com/2022/03/13/React%E5%AD%A6%E4%B9%A020220313%20Hook/",
            "title": "React学习20220313 Hook",
            "date_published": "2022-03-13T03:48:15.000Z",
            "content_html": "<h1 id=\"react学习20220313-hook\"><a class=\"anchor\" href=\"#react学习20220313-hook\">#</a> React 学习 20220313 Hook</h1>\n<h2 id=\"理解hook\"><a class=\"anchor\" href=\"#理解hook\">#</a> 理解 Hook</h2>\n<p>按我的理解，Hook 是对繁琐，学习曲线长，难以更改中间步骤的类的拆分，使得函数可以拥有一些类能够使用的功能：如 state 和生命周期等，而且 Hook 所辅助的函数式编程比较符合 React 所推崇的组件化编程。</p>\n<h2 id=\"对usestate的理解\"><a class=\"anchor\" href=\"#对usestate的理解\">#</a> 对 useState 的理解</h2>\n<p>充当函数中的 state，但一次只有一个，不像类中一次指定多个</p>\n<blockquote>\n<p>[text,setText] =useState (‘初始文字’)</p>\n</blockquote>\n<p>useState 返回一个数组，数组第一个是想要的 state 变量，第二个是修改变量的 Api</p>\n<h2 id=\"对useeffect的理解\"><a class=\"anchor\" href=\"#对useeffect的理解\">#</a> 对 useEffect 的理解</h2>\n<p>弥补生命周期</p>\n<p>接收两个参数：回调函数和依赖数组</p>\n<p>useEffect(callBack,[])</p>\n<p>调用规则：</p>\n<blockquote>\n<p>每次渲染后：传入回调函数，不传依赖数组：</p>\n<ul>\n<li>useEffect(callBack)</li>\n</ul>\n<p>挂载阶段执行一次后不再执行：传入回调函数，且此函数的返回值不是函数，同时传入空数组。</p>\n<ul>\n<li>useEffect (()=&gt;{/* 业务逻辑 */},[])</li>\n</ul>\n<p>仅在挂载和卸载阶段执行的：传入回调函数，且此函数的返回值是一个函数</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 业务逻辑</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 返回一个函数记为 B</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>每次渲染都触发，且卸载阶段也会被触发的：传入回调函数，且这个函数的返回值是一个函数，同时不传第二个参数</p>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">//A 的业务逻辑</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token comment\">// 返回一个函数记为 B</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>上面这段代码在每次渲染都触发 A 逻辑，并在卸载阶段触发 B 逻辑</p>\n<p>按我的理解，在前面一半写个函数会在渲染阶段一直触发，单纯写一段逻辑就会在挂载阶段触发，在 return 那写个函数就会在卸载的时候触发</p>\n</blockquote>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220313%20Hook/assets/image-20220313160121838.png\" alt=\"image-20220313160121838\" /></p>\n<h2 id=\"不要在循环条件或嵌套函数中调用hook\"><a class=\"anchor\" href=\"#不要在循环条件或嵌套函数中调用hook\">#</a> 不要在循环，条件或嵌套函数中调用 Hook</h2>\n<h3 id=\"首次渲染过程\"><a class=\"anchor\" href=\"#首次渲染过程\">#</a> 首次渲染过程</h3>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220313%20Hook/assets/image-20220314135945234.png\" alt=\"image-20220314135945234\" /></p>\n<p>hook 相关的所有信息收敛在一个 hook 对象粒，而 hook 对象之间以单向链表的形式相互串联，</p>\n<h3 id=\"更新过程\"><a class=\"anchor\" href=\"#更新过程\">#</a> 更新过程</h3>\n<p><img data-src=\"G:/WorkStation/JavaScriptProject/React%E5%AD%A6%E4%B9%A0/React%E5%AD%A6%E4%B9%A020220313%20Hook/assets/image-20220314140737526.png\" alt=\"image-20220314140737526\" /></p>\n<p>因此，hooks 的渲染是通过 “依次遍历”（也就是说，它只会管这回需要前进几个 next，而不会对对应位置的真实性进行判断）来定位每个 hooks 的内容的，如果前后两次读到的链表顺序出现差异，那么渲染的结果自然是不可控的。</p>\n",
            "tags": [
                "React"
            ]
        },
        {
            "id": "http://example.com/2022/03/12/React%E5%AD%A6%E4%B9%A020220312/",
            "url": "http://example.com/2022/03/12/React%E5%AD%A6%E4%B9%A020220312/",
            "title": "React学习20220312 生命周期",
            "date_published": "2022-03-12T03:48:15.000Z",
            "content_html": "<h1 id=\"react学习20220312\"><a class=\"anchor\" href=\"#react学习20220312\">#</a> React 学习 20220312</h1>\n<h2 id=\"createelement函数拆解\"><a class=\"anchor\" href=\"#createelement函数拆解\">#</a> CreateElement 函数拆解</h2>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312150556893.png&quot; alt=&quot;image-20220312150556893&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312150653145.png&quot; alt=&quot;image-20220312150653145&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312150814067.png&quot; alt=&quot;image-20220312150814067&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312150922420.png&quot; alt=&quot;image-20220312150922420&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h2 id=\"生命周期\"><a class=\"anchor\" href=\"#生命周期\">#</a> 生命周期</h2>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220312151139289.png\" alt=\"image-20220312151139289\" /></p>\n<p>React16</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220312152345970.png\" alt=\"image-20220312152345970\" /></p>\n<blockquote>\n<p>挂载过程</p>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312152839851.png&quot; alt=&quot;image-20220312152839851&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>getDerivedFromProps 的功能：使用 props 来派生 / 更新 state</p>\n<ul>\n<li>是针对某个属性的定向更新</li>\n</ul>\n<p>更新过程</p>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312153339553.png&quot; alt=&quot;image-20220312153339553&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>getSnapshotBeforeUpdate:</p>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312154540844.png&quot; alt=&quot;image-20220312154540844&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312154512940.png&quot; alt=&quot;image-20220312154512940&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n</blockquote>\n<p>React16 引入的 Fiber 架构</p>\n<p>之前组件更新：树状递归更新，同步更新，占用主线程，易卡死</p>\n<p>Fiber 会把大任务转为小任务，使得渲染线程可打断</p>\n<p>重要特征</p>\n<blockquote>\n<p>可以被 &lt;u&gt; 打断 &lt;/u &gt; 的异步渲染模式</p>\n</blockquote>\n<p>react 将渲染过程分为 render 和 commit 两个过程</p>\n<p>render 可被打断</p>\n<p>commit 同步执行</p>\n<p>因为 commit 会改视图，因此不可打断</p>\n<h2 id=\"数据的流动\"><a class=\"anchor\" href=\"#数据的流动\">#</a> 数据的流动</h2>\n<p>基于 props 的单向数据流：</p>\n<blockquote>\n<p>当前组件的 state 以 props 的形式流动时，只能流向组件树中比自己层级更低的组件</p>\n</blockquote>\n<p>父子组件通信</p>\n<blockquote>\n<p>父组件把 this.props 传入子组件</p>\n</blockquote>\n<p>子父组件通信</p>\n<blockquote>\n<p>父组件向子组件传递一个绑定了自身上下文的函数</p>\n<p>子组件在调用该函数时，</p>\n<p>就可以把想要交给父组件的数据以函数入参的形式传入</p>\n<blockquote>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312163654393.png&quot; alt=&quot;image-20220312163654393&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312163734257.png&quot; alt=&quot;image-20220312163734257&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220312163752751.png&quot; alt=&quot;image-20220312163752751&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n</blockquote>\n</blockquote>\n",
            "tags": [
                "React"
            ]
        },
        {
            "id": "http://example.com/2022/03/11/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/",
            "url": "http://example.com/2022/03/11/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95/",
            "title": "黑盒测试",
            "date_published": "2022-03-11T01:48:15.000Z",
            "content_html": "<p>测试用例选择</p>\n<ol>\n<li>为每一个等价类规定一个唯一编号；</li>\n<li>设计一个新的测试用例，使其尽可能多地覆盖 尚未被覆盖的有效等价类，重复这一步，直到 所有的有效等价类都被覆盖为止；</li>\n<li>设计一个新的测试用例，使其仅覆盖一个尚未 被覆盖的无效等价类，重复这一步，直到所有 的无效等价类都被覆盖为止</li>\n</ol>\n<blockquote>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220309134921110.png\" alt=\"image-20220309134921110\" /></p>\n<h4 id=\"分类\"><a class=\"anchor\" href=\"#分类\">#</a> 分类</h4>\n<h4 id=\"是否是三角形的三条边\"><a class=\"anchor\" href=\"#是否是三角形的三条边\">#</a> 是否是三角形的三条边</h4>\n<h6 id=\"等价类\"><a class=\"anchor\" href=\"#等价类\">#</a> 等价类</h6>\n<p>A&gt;0</p>\n<p>B&gt;0</p>\n<p>c&gt;0</p>\n<p>A+B&gt;C</p>\n<p>B+C&gt;A</p>\n<p>A+C&gt;B</p>\n<h5 id=\"非等价类\"><a class=\"anchor\" href=\"#非等价类\">#</a> 非等价类</h5>\n<p>A&lt;=0</p>\n<p>B&lt;=0</p>\n<p>C&lt;=0</p>\n<p>A+B&lt;=C</p>\n<p>…</p>\n<h4 id=\"是否等腰\"><a class=\"anchor\" href=\"#是否等腰\">#</a> 是否等腰</h4>\n<h5 id=\"等价类-2\"><a class=\"anchor\" href=\"#等价类-2\">#</a> 等价类</h5>\n<p>A=B</p>\n<p>B=C</p>\n<p>C=A</p>\n<h5 id=\"非等价类-2\"><a class=\"anchor\" href=\"#非等价类-2\">#</a> 非等价类</h5>\n<p>A!=B！=C</p>\n<h5 id=\"是否等边\"><a class=\"anchor\" href=\"#是否等边\">#</a> 是否等边</h5>\n<h5 id=\"等价类-3\"><a class=\"anchor\" href=\"#等价类-3\">#</a> 等价类</h5>\n<p>A=B=C</p>\n<h5 id=\"非等价类-3\"><a class=\"anchor\" href=\"#非等价类-3\">#</a> 非等价类</h5>\n<p>A!=B</p>\n<p>B!=C</p>\n<p>C!=A</p>\n</blockquote>\n<h3 id=\"边界值分析法单缺陷假设\"><a class=\"anchor\" href=\"#边界值分析法单缺陷假设\">#</a> 边界值分析法（单缺陷假设）</h3>\n<p>比最大值稍微小一点，比最小值稍微大一点</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220309140314690.png\" alt=\"image-20220309140314690\" /></p>\n<p><strong>健壮性测试：（再多两个点）</strong></p>\n<p>比最大值稍微大一点，比最小值稍微小一点</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220309140305899.png\" alt=\"image-20220309140305899\" /></p>\n<p><strong>最坏情况测试：</strong></p>\n<p>多变量取极值的情况</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220309140255646.png\" alt=\"image-20220309140255646\" /></p>\n<p><strong>健壮最坏情况测试</strong></p>\n<p>最坏情况取超边界情况</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220309140405550.png\" alt=\"image-20220309140405550\" /></p>\n<h3 id=\"错误推测法\"><a class=\"anchor\" href=\"#错误推测法\">#</a> 错误推测法</h3>\n<p>根据经验推测</p>\n<p>简单有效，但系统性差，是其他的补充</p>\n<h3 id=\"判定表法\"><a class=\"anchor\" href=\"#判定表法\">#</a> 判定表法</h3>\n<blockquote>\n<p>判定表是一种用来表示和分析复杂逻辑关系的工具，最适 合描述在多个逻辑条件取值的组合所构成的复杂情况下， 分别要执行哪些不同的动作。</p>\n</blockquote>\n<blockquote>\n<p>条件桩（Condition Stub）：列出了问题的所有条件。通常认为列出的条件的次序无关紧要。</p>\n<p>动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。</p>\n<p>条件项（Condition Entry）：列出针对它所列条件的取值，在所有可能情况下的真假值。</p>\n<p>动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作</p>\n</blockquote>\n<p>例子</p>\n<blockquote>\n<p>“…… 对于功率大于 50 马力的机器，并且维修记录不全或已运行 10 年以上的机器，应给予优先的维修处理……</p>\n<p>（1）列出所有的条件桩和动作桩</p>\n<p>– 条件桩 C1：功率大于 50 马力吗？ C2：维修记录不全吗？ C3：运行超过 10 年吗？</p>\n<p>– 动作桩 A1：进行优先处理 A2：做其他处理</p>\n<p>（2）确定规则个数</p>\n<p>– 输入条件个数：3</p>\n<p>– 每个条件的取值：“是” 或 “否”</p>\n<p>– 规则个数：2<em>2</em>2 =8</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220309143736908.png\" alt=\"image-20220309143736908\" /></p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220309143751694.png\" alt=\"image-20220309143751694\" /></p>\n</blockquote>\n<blockquote>\n<p>因果图法</p>\n<blockquote>\n<p>从用自然语言书写的程序规格说明 的描述中找出因（输入条件）和果（输出或程序状态的改 变），通过因果图转换为判定表</p>\n</blockquote>\n<p>基本步骤</p>\n<blockquote>\n<ol>\n<li>\n<p>分析软件规格说明描述中，哪些是原因（即输入条件或输入 条件的等价类），哪些是结果（即输出条件），并给每个原因和 结果赋予一个标识符。</p>\n</li>\n<li>\n<p>分析软件规格说明描述中的语义，找出原因与结果之间，原 因与原因之间对应的关系，根据这些关系，画出因果图</p>\n</li>\n<li>\n<p>由于语法或环境限制，有些原因与原因之间，结果与结果之 间的组合情况不可能出现。为表明这些特殊情况，在因果图上用 一些记号标明约束或限制条件</p>\n</li>\n<li>\n<p>把因果图转换成判定表。</p>\n</li>\n<li>\n<p>把判定表的每一列拿出来作为依据，设计测试用例</p>\n</li>\n</ol>\n<p>图形符号</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220311152714975.png\" alt=\"image-20220311152714975\" /></p>\n<p><img data-src=\"https://s2.loli.net/2022/03/11/2Izxij3sJbMwBCX.png\" alt=\"image-20220311152824009\" /></p>\n</blockquote>\n</blockquote>\n",
            "tags": [
                "软件质量与评测技术"
            ]
        },
        {
            "id": "http://example.com/2022/03/09/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/",
            "url": "http://example.com/2022/03/09/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95/",
            "title": "白盒测试",
            "date_published": "2022-03-09T01:48:15.000Z",
            "content_html": "<h1 id=\"白盒测试\"><a class=\"anchor\" href=\"#白盒测试\">#</a> 白盒测试</h1>\n<h2 id=\"定义\"><a class=\"anchor\" href=\"#定义\">#</a> 定义</h2>\n<p>知道内部工作过程，可通过测试内部动作来测试</p>\n<h3 id=\"目标\"><a class=\"anchor\" href=\"#目标\">#</a> 目标</h3>\n<p>通过测试来检测软件产品内部动作是否按照规格说明书的规定正常执行</p>\n<h3 id=\"重点\"><a class=\"anchor\" href=\"#重点\">#</a> 重点</h3>\n<p>看软件内部各条通路是否按照规定工作</p>\n<h3 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点</h3>\n<p>黑盒可能存在负负得正的情况，而白盒不会</p>\n<p>白盒能发现一些隐患：如内存泄漏，误差累积等</p>\n<h2 id=\"作用\"><a class=\"anchor\" href=\"#作用\">#</a> 作用</h2>\n<h3 id=\"主要想对程序模块进行如下的检查\"><a class=\"anchor\" href=\"#主要想对程序模块进行如下的检查\">#</a> 主要想对程序模块进行如下的检查</h3>\n<blockquote>\n<p>对所有独立测试路径至少测试一次</p>\n<p>对所有的逻辑判定，取真 / 假的两种至少测试一次</p>\n<p>在循环的边界和运行界限内执行循环体</p>\n<p>测试内部数据结构的有效性</p>\n</blockquote>\n<h3 id=\"局限\"><a class=\"anchor\" href=\"#局限\">#</a> 局限</h3>\n<p>一个具有多重选择和循环嵌套的程序，不同的路径数目可能是天文数字。</p>\n<h2 id=\"比较\"><a class=\"anchor\" href=\"#比较\">#</a> 比较</h2>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220311162005086.png&quot; alt=&quot;image-20220311162005086&quot; style=&quot;zoom: 50%;&quot; /&gt;</p>\n<h2 id=\"如何安排白盒测试\"><a class=\"anchor\" href=\"#如何安排白盒测试\">#</a> 如何安排白盒测试</h2>\n<h3 id=\"单元测试\"><a class=\"anchor\" href=\"#单元测试\">#</a> 单元测试</h3>\n<h3 id=\"集成测试\"><a class=\"anchor\" href=\"#集成测试\">#</a> 集成测试</h3>\n<blockquote>\n<ul>\n<li>\n<p>集成阶段，依据概要设计说明书</p>\n</li>\n<li>\n<p>静态结构分析</p>\n</li>\n<li>\n<p>代码质量度量</p>\n</li>\n<li>\n<p>功能确认与接口分析</p>\n</li>\n<li>\n<p>覆盖率分析</p>\n</li>\n<li>\n<p>性能分析</p>\n</li>\n<li>\n<p>内存分析</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"系统测试\"><a class=\"anchor\" href=\"#系统测试\">#</a> 系统测试</h3>\n<p>到这步已经很少做白盒测试了</p>\n<h3 id=\"验收测试\"><a class=\"anchor\" href=\"#验收测试\">#</a> 验收测试</h3>\n<h3 id=\"白盒测试综合策略\"><a class=\"anchor\" href=\"#白盒测试综合策略\">#</a> 白盒测试综合策略</h3>\n<blockquote>\n<ol>\n<li>\n<p>在测试中，应尽量先用工具进行静态结构分析。</p>\n</li>\n<li>\n<p>测试中可采取先静态后动态的组合方式：先进行静态结构分析、代码检查和静态质量度量，再进行覆盖率测试。</p>\n</li>\n<li>\n<p>利用静态分析的结果作为引导，通过代码检查和动态测试的方式对静态结构分析结果进行进一步的确认，使测试工作更为有效</p>\n</li>\n<li>\n<p>覆盖率测试是白盒测试的重点，一般可使用基本路径测试 法达到语句覆盖标准；对于软件的重点模块，应使用多种覆盖标准衡量代码的覆盖率。</p>\n</li>\n<li>\n<p>在不同的测试阶段，测试的侧重点不同：在单元测试阶段 ，以代码检查、逻辑覆盖为主；在集成测试阶段，需要增加静态结构分析、静态质量度量；在系统测试阶段，应根据黑盒测试的结果，采取相应的白盒测试</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"白盒测试用例设计技术\"><a class=\"anchor\" href=\"#白盒测试用例设计技术\">#</a> 白盒测试用例设计技术</h2>\n<h3 id=\"静态\"><a class=\"anchor\" href=\"#静态\">#</a> 静态</h3>\n<blockquote>\n<ul>\n<li>\n<p>代码检查（人工＋工具）</p>\n</li>\n<li>\n<p>静态结构分析（主要由软件工具自动进行）</p>\n</li>\n<li>\n<p>软件质量度量（主要由软件工具自动进行</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"动态\"><a class=\"anchor\" href=\"#动态\">#</a> 动态</h3>\n",
            "tags": [
                "软件质量与评测技术"
            ]
        },
        {
            "id": "http://example.com/2021/12/19/2021-12-19-MC%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/",
            "url": "http://example.com/2021/12/19/2021-12-19-MC%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/",
            "title": "MC服务器设置",
            "date_published": "2021-12-19T12:43:23.000Z",
            "content_html": "<h1 id=\"mc服务器设置\"><a class=\"anchor\" href=\"#mc服务器设置\">#</a> MC 服务器设置</h1>\n<p>[toc]</p>\n<p>今天心血来潮搞了个 mc 服务器，下面记录一下过程</p>\n<h2 id=\"基础配置\"><a class=\"anchor\" href=\"#基础配置\">#</a> 基础配置</h2>\n<p>服务器系统：Debian (我也不知道是什么版本，反正是 vultur 上买的)</p>\n<p>java 版本:openjdk8 具体下载过程在后面有说</p>\n<p>之后参考教程<span class=\"exturl\" data-url=\"aHR0cHM6Ly9taW5lY3JhZnQuZmFuZG9tLmNvbS96aC93aWtpLyVFNiU5NSU5OSVFNyVBOCU4Qi8lRTYlOUUlQjYlRTglQUUlQkUlRTYlOUMlOEQlRTUlOEElQTElRTUlOTklQTgjRGViaWFuLkUzLjgwLjgxVWJ1bnR1LkU1LjkyLjhDUmFzcGJpYW4=\">教程 / 架设服务器 - Minecraft Wiki，最详细的我的世界百科 (fandom.com)</span></p>\n<h2 id=\"java下载\"><a class=\"anchor\" href=\"#java下载\">#</a> java 下载</h2>\n<p>参考: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubXlmcmVheC5jb20vaW5zdGFsbC1qYXZhLW9uLWRlYmlhbi0xMC8=\">如何在 Debian 10 Linux 上安装 Java (myfreax.com)</span></p>\n<p>执行以下代码即可</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> apt-transport-https ca-certificates <span class=\"token function\">wget</span> dirmngr gnupg software-properties-com</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">wget</span> -qO - https://adoptopenjdk.jfrog.io/adoptopenjdk/api/gpg/key/public <span class=\"token operator\">|</span> <span class=\"token function\">sudo</span> apt-key <span class=\"token function\">add</span> -</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">sudo</span> add-apt-repository --yes https://adoptopenjdk.jfrog.io/adoptopenjdk/deb/</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> adoptopenjdk-8-hotspot</pre></td></tr></table></figure><p>最后看看是否真的安装了</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>java -version</pre></td></tr></table></figure><p>预计输出如下</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>openjdk version <span class=\"token string\">\"1.8.0_212\"</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>OpenJDK Runtime Environment <span class=\"token punctuation\">(</span>AdoptOpenJDK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>build <span class=\"token number\">1.8</span>.0_212-b04<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>OpenJDK <span class=\"token number\">64</span>-Bit Server VM <span class=\"token punctuation\">(</span>AdoptOpenJDK<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>build <span class=\"token number\">25.212</span>-b04, mixed mode<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"服务器配置\"><a class=\"anchor\" href=\"#服务器配置\">#</a> 服务器配置</h2>\n<p>基础代码仓我直接用了已有的 github 仓库 (不想自己搞了)</p>\n<p>直接在 Linux 命令行下输入这些就行</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">wget</span> https://github.com/silvertriclops/MCSLI/archive/master.zip</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">unzip</span> master.zip</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin class-name\">cd</span> MCSLI-master </pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">chmod</span> +x install.sh</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">chmod</span> +x start.sh</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>./install.sh <span class=\"token comment\"># tells the computer where Java is so it knows how to start Minecraft</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>./start.sh <span class=\"token comment\"># starts the Minecraft server. You may want to run this command inside screen.</span></pre></td></tr></table></figure><p>理论上来说，这样就已经可以用了</p>\n<p>输入 stop 退出</p>\n<h3 id=\"开放tcp端口\"><a class=\"anchor\" href=\"#开放tcp端口\">#</a> 开放 tcp 端口</h3>\n<p>因为是服务器，需要和客户端交互，一个 tcp 端口是必不可少的</p>\n<p>一般来说，根据上面创建的服务器，默认使用的是 25565 (启动的时候中间有一行会提示的)</p>\n<p>就像下面这样</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/19/m8LxWjMp3DFeXkA.png\" alt=\"image-20211219204134588\" /></p>\n<p>然后输入下面代码就能开放对应端口 (不过我也不知道开了到底会有什么坏影响，服务器做好备份？)</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> iptables -A INPUT -p tcp --dport <span class=\"token number\">25565</span> --jump ACCEPT</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>iptables-save</pre></td></tr></table></figure><h2 id=\"换成我想要的版本112\"><a class=\"anchor\" href=\"#换成我想要的版本112\">#</a> 换成我想要的版本 (1.12)</h2>\n<p>不过这个仓库七年前就停止更新了，里面的服务器版本为 1.8 版本</p>\n<p>想更新成自己的版本需要去 MC 官网下，就几十 mb 很小，下载好对应版本后</p>\n<p>回到之前的文件夹 (MCSLI-master)</p>\n<p>把对应版本的文件放进来</p>\n<p>如果不知道怎么把文件传给服务器，看下面</p>\n<blockquote>\n<p>我用的 Xshell 连接服务器，这时候可以下载 xftp, 用于文件传输，图形化界面，用了都说好</p>\n</blockquote>\n<p>之后更改配置 (MCSLI-master/start.sh)</p>\n<p>里面能看到写了一行启动代码，把它里面对应服务器 jar 包的那部分换成你的 jar 包 (相对位置绝对位置都可以)</p>\n<p>看看能不能用</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>./start.sh</pre></td></tr></table></figure><p>只要不报错就算成功</p>\n<h2 id=\"加装mod\"><a class=\"anchor\" href=\"#加装mod\">#</a> 加装 mod</h2>\n<p>mod 是 mc 的灵魂，不打 mod 我不认可 (实际就是我菜)</p>\n<p>这时候需要下载 forge</p>\n<p>打开 forge 的官网</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9maWxlcy5taW5lY3JhZnRmb3JnZS5uZXQvbmV0L21pbmVjcmFmdGZvcmdlL2ZvcmdlL2luZGV4XzEuMTIuaHRtbA==\">Downloads for Minecraft Forge for Minecraft 1.12</span></p>\n<p>下载对应的版本，我是 1.12 就下载了 1.12</p>\n<p>放到和刚才文件同一级目录下</p>\n<p>执行</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>java -jar forge-1.12-14.21.1.2443-installer.jar --install</pre></td></tr></table></figure><p>这时候你使用 ls 看看文件夹下，可以看到有类似</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/19/4iMHgdhOJsvQR9V.png\" alt=\"image-20211219203443648\" /></p>\n<p>这种东西出现</p>\n<p>那么你的 forge 安装已经成功了一半了</p>\n<p>之后打开你该死的本地 MC (加装了对应版本 forge 的那种)</p>\n<p>把.minecraft 下的 resources 文件夹，整个给复制到服务器里头去 (还是刚才那个文件目录)</p>\n<p>之后执行</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>./start.sh</pre></td></tr></table></figure><p>最后能看到这些信息就算成功</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/19/1QMTqoABd5gaxeF.png\" alt=\"image-20211219203701426\" /></p>\n<h2 id=\"享受服务器\"><a class=\"anchor\" href=\"#享受服务器\">#</a> 享受服务器</h2>\n<p>打开你的本地 MC, 输入服务器 ip, 连接后进入就行</p>\n<h2 id=\"啸贴士\"><a class=\"anchor\" href=\"#啸贴士\">#</a> 啸贴士</h2>\n<p>如果你一不小心做错了，或许可以评论，我期末摸鱼的时候可能会来评论一下</p>\n",
            "tags": [
                "MC"
            ]
        },
        {
            "id": "http://example.com/2021/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/",
            "url": "http://example.com/2021/12/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/",
            "title": "计算机网络复习",
            "date_published": "2021-12-11T12:22:23.000Z",
            "content_html": "<h1 id=\"计网复习\"><a class=\"anchor\" href=\"#计网复习\">#</a> 计网复习</h1>\n<h2 id=\"大纲\"><a class=\"anchor\" href=\"#大纲\">#</a> 大纲</h2>\n<p>[toc]</p>\n<h2 id=\"1-计算机网络体系结构\"><a class=\"anchor\" href=\"#1-计算机网络体系结构\">#</a> 1. 计算机网络体系结构</h2>\n<h3 id=\"11-计算机网络概述\"><a class=\"anchor\" href=\"#11-计算机网络概述\">#</a> 1.1  计算机网络概述</h3>\n<h4 id=\"111计算机网络的概念-组成\"><a class=\"anchor\" href=\"#111计算机网络的概念-组成\">#</a> 1.1.1 计算机网络的概念、组成</h4>\n<p>概念</p>\n<blockquote>\n<p>计算机网络就是通过交换机，路由器等网络设备和通信线路将分散在不同地理位置的多个计算机系统连接起来，在网络协议和应用软件的控制下实现各种网络服务的系统.</p>\n<ul>\n<li>资源共享 - 最终目的</li>\n<li>数据通信 - 资源共享的前提</li>\n</ul>\n</blockquote>\n<p>网络的结构</p>\n<blockquote>\n<ul>\n<li>\n<p>网络边缘 (network edge)- 服务端和客户端</p>\n<ul 传输速率=\"\">\n<li>\n<p>服务端功能：发送分组数据</p>\n<blockquote>\n<p>收到应用数据 -&gt; 拆解为小组块 -&gt; 以 R 传输速率 (带宽 bandwidth) 进行传输</p>\n<p>传输延迟L_{比特数}/R_</p>\n</blockquote>\n</li>\n</ul>\n<hr />\n</li>\n<li>\n<p>接入网络 (access networks)- 物理介质</p>\n<ul>\n<li>\n<p>物理层：发送端和接收端之间</p>\n</li>\n<li>\n<p>导引型介质 (guided media)</p>\n<ul>\n<li>\n<p>固体介质 - 铜线，光纤 (optical fiber), 同轴电缆 (coaxial cable)</p>\n<blockquote>\n<p>双绞线：螺旋排列减小电磁干扰</p>\n<p>同轴电缆：单信道 / 多信道</p>\n<p>光纤：光脉冲，低差错率，无电磁干扰</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>非导引型介质 (unguided media)</p>\n<ul>\n<li>自由发信号</li>\n<li>e.g. 无线电</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>网络核心 (network core)- 互联的路由器</p>\n<ul>\n<li>\n<p>路由器网络</p>\n</li>\n<li>\n<p>分组交换</p>\n<blockquote>\n<p>主机把报文分解成分组</p>\n<p>网络核心转发分组 (从源头到目的)-</p>\n<blockquote>\n<p>单个分组传输到相邻节点，存储下来后查转发表，转发到下一节点。</p>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"112计算机网络的分类\"><a class=\"anchor\" href=\"#112计算机网络的分类\">#</a> 1.1.2 计算机网络的分类</h4>\n<ul>\n<li>\n<ol>\n<li>\n<p>Transmission technology 传输技术<br />\n广播链路</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/10/NuIQEO7LD1os5cP.png\" alt=\"image-20211210103557833\" /> 点到点链路<br />\n<img data-src=\"https://s2.loli.net/2021/12/10/sZGIdi3TYz1kU8j.png\" alt=\"image-20211210103606005\" /></p>\n</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>Scale 距离尺度<br />\n局域网 LAN 10~1km<br />\n 城域网 MAN 1km~10km<br />\n 广域网 WAN 100km~</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>Topology 拓扑结构<br />\n星形什么的，看名字就知道了</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>Switching 交换\n<ol>\n<li>\n<p>Packet Switching 分组交换</p>\n</li>\n<li>\n<p>Circuit Switching 电路交换</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"113计算机网络与互联网的发展历史不考\"><a class=\"anchor\" href=\"#113计算机网络与互联网的发展历史不考\">#</a> 1.1.3 计算机网络与互联网的发展历史 [不考]</h4>\n<p>1961-1972: Early packet-switching principles 分组交换的发展</p>\n<p>1972-1980: Internetworking, new and proprietary nets 网络互联。专用网络<br />\n 1980-1990: new protocols, a proliferation of networks 网络的激增<br />\n 1990, 2000’s: commercialization, the Web, new apps 商业化</p>\n<p>2005-present</p>\n<h4 id=\"114计算机网络的标准化工作及相关组织不考\"><a class=\"anchor\" href=\"#114计算机网络的标准化工作及相关组织不考\">#</a> 1.1.4 计算机网络的标准化工作及相关组织 [不考]</h4>\n<p>IETF (因特网工程任务组)</p>\n<p>IEEE802 - 局域网 / 城域网标准委员会，指定相关标准</p>\n<h3 id=\"12计算机网络体系结构与参考模型\"><a class=\"anchor\" href=\"#12计算机网络体系结构与参考模型\">#</a> 1.2 计算机网络体系结构与参考模型</h3>\n<h4 id=\"121计算机网络分层结构\"><a class=\"anchor\" href=\"#121计算机网络分层结构\">#</a> 1.2.1 计算机网络分层结构</h4>\n<h4 id=\"122计算机网络协议-接口-服务等概念\"><a class=\"anchor\" href=\"#122计算机网络协议-接口-服务等概念\">#</a> 1.2.2 计算机网络协议、接口、服务等概念</h4>\n<p>服务：层的功能</p>\n<p>协议：同一层的对等实体间的交流服务</p>\n<p>接口：告诉上层如何访问</p>\n<h4 id=\"123isoosi参考模型和tcpip模型\"><a class=\"anchor\" href=\"#123isoosi参考模型和tcpip模型\">#</a> 1.2.3ISO/OSI 参考模型和 TCP/IP 模型</h4>\n<p>ISO/OSI 参考模型</p>\n<blockquote>\n<p>ISO: international Standards Organization</p>\n<p>OSI: Open Systems Interconnection</p>\n<blockquote>\n<p>・application: 支持网络应用<br />\n・presentation: 允许应用程序解释数据的意义，如加密、压缩<br />\n・session: 数据交换的同步，检查和恢复<br />\n・transport: 进程到进程的数据传输 (端到端)<br />\n・network: 为数据报选择从源主机到目的主机 的路径<br />\n・data link: 在邻近网元之间传输数据</p>\n<p>・physical: 在介质上传输原始比特</p>\n</blockquote>\n</blockquote>\n<p>TCP/IP 参考模型</p>\n<blockquote>\n<p>协议栈</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/10/kUG5MQbEuSVAtI6.png\" alt=\"image-20211210105419434\" /></p>\n</blockquote>\n<p>下图左为 OSI, 右为 TCP/IP</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwL2x0TlA3V2s4S1NFYkRxby5wbmc=\">https://s2.loli.net/2021/12/10/ltNP7Wk8KSEbDqo.png</span>&quot; alt=&quot;image-20211210105133165&quot; style=&quot;zoom: 67%;&quot; /&gt;</p>\n<p><strong>混合模型 (Hybrid Model)</strong></p>\n<p>本课程使用的模型</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/10/iQgX5ac8sJFutrI.png\" alt=\"image-20211210105705057\" /></p>\n<h4 id=\"传世经典bushi-数据传输过程中在各层发生的变化\"><a class=\"anchor\" href=\"#传世经典bushi-数据传输过程中在各层发生的变化\">#</a> 传世经典 (bushi)- 数据传输过程中在各层发生的变化</h4>\n<p><img data-src=\"https://s2.loli.net/2021/12/10/1K3IgykaHvdcUsb.png\" alt=\"image-20211210105729673\" /></p>\n<h3 id=\"13计算机网络性能指标\"><a class=\"anchor\" href=\"#13计算机网络性能指标\">#</a> 1.3 计算机网络性能指标</h3>\n<p>吞吐量 Throughput - 传输位数 / 传输时间</p>\n<ul>\n<li>带宽是吞吐量的绝对上限</li>\n</ul>\n<p>带宽 Bandwidth</p>\n<blockquote>\n<p>在单位时间内，从网络中的某一点到另一点所能通过的位数</p>\n</blockquote>\n<p>时延 / 延迟 Delay</p>\n<blockquote>\n<p>一个数据库从网络的一端传送到另一端所需要的时间</p>\n<p>时延 = 处理时延 + 排队时延 + 传输时延 + 传播时延</p>\n<ul>\n<li>传输时延 - 数据量 / 带宽</li>\n<li>传播时延 - 传输距离 / 光速</li>\n<li>往返时延 (RTT)- 从发送端发出，到发送端收到接收端的确认的总时延</li>\n</ul>\n<ul>\n<li>端到端时延 - 分组从源主机到目的主机路径上每个节点时延的总和</li>\n<li>时延带宽积 - 传播时延 * 带宽</li>\n</ul>\n</blockquote>\n<h2 id=\"2-应用层\"><a class=\"anchor\" href=\"#2-应用层\">#</a> 2. 应用层</h2>\n<h3 id=\"21-应用层协议原理\"><a class=\"anchor\" href=\"#21-应用层协议原理\">#</a> 2.1  应用层协议原理</h3>\n<h4 id=\"211网络应用程序的体系结构\"><a class=\"anchor\" href=\"#211网络应用程序的体系结构\">#</a> 2.1.1 网络应用程序的体系结构</h4>\n<h5 id=\"client-servercs\"><a class=\"anchor\" href=\"#client-servercs\">#</a> Client-Server(C/S)</h5>\n<p>server:</p>\n<blockquote>\n<p>永远在线</p>\n<p>永久 ip</p>\n<p>服务器集群增强可扩展性</p>\n</blockquote>\n<p>client</p>\n<blockquote>\n<p>与服务器交互</p>\n<p>动态 IP 地址</p>\n<p>客户机之间不直接通信</p>\n</blockquote>\n<h5 id=\"peer-to-peerp2p\"><a class=\"anchor\" href=\"#peer-to-peerp2p\">#</a> Peer-to-Peer(P2P)</h5>\n<blockquote>\n<p>没有长期存在的服务端</p>\n<p>端系统之间直接通信</p>\n<p>对等方向其他对等方 (Peer) 请求服务，同时给其他 peer 提供服务</p>\n<p>对等方间歇性连接，IP 可变</p>\n</blockquote>\n<h4 id=\"212可供应用层使用的传输层服务\"><a class=\"anchor\" href=\"#212可供应用层使用的传输层服务\">#</a> 2.1.2 可供应用层使用的传输层服务</h4>\n<p>app 需要什么？</p>\n<blockquote>\n<p>数据完整性</p>\n<p>吞吐量</p>\n<p>时效性</p>\n<p>安全性</p>\n</blockquote>\n<p>TCP</p>\n<blockquote>\n<p>提供</p>\n<ul>\n<li>\n<p>面向连接</p>\n</li>\n<li>\n<p>可靠传输</p>\n</li>\n<li>\n<p>流量控制</p>\n</li>\n<li>\n<p>拥塞控制</p>\n</li>\n</ul>\n<p>不提供</p>\n<ul>\n<li>定时 (时效性)</li>\n<li>最小带宽保证</li>\n</ul>\n</blockquote>\n<p>UDP</p>\n<blockquote>\n<p>不可靠数据传输</p>\n<p>不提供</p>\n<blockquote>\n<p>流量控制</p>\n<p>连接建立</p>\n<p>可靠性</p>\n<p>拥塞控制</p>\n<p>时效性</p>\n<p>最小带宽保证</p>\n</blockquote>\n</blockquote>\n<h5 id=\"因特网使用的应用层协议和传输层协议\"><a class=\"anchor\" href=\"#因特网使用的应用层协议和传输层协议\">#</a> 因特网使用的应用层协议和传输层协议</h5>\n<p><img data-src=\"https://s2.loli.net/2021/12/10/VqOfA9pZeRUbgP6.png\" alt=\"image-20211210111555991\" /></p>\n<h3 id=\"22应用层协议\"><a class=\"anchor\" href=\"#22应用层协议\">#</a> 2.2 应用层协议</h3>\n<h4 id=\"221web和http\"><a class=\"anchor\" href=\"#221web和http\">#</a> 2.2.1Web 和 HTTP</h4>\n<p>http: 超文本传输协议</p>\n<blockquote>\n<p>使用 TCP 协议</p>\n<ul>\n<li>客户端初始化传输端口，发送给服务端</li>\n<li>服务端接受连接请求</li>\n<li>交换信息</li>\n<li>连接关闭</li>\n</ul>\n<p>非持久 http: 每个连接只发送一个对象 (HTTP/1.0)</p>\n<p>例子</p>\n<ul>\n<li>\n<blockquote>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwL1RBQ3NHYWx0SU1XY3VWOS5wbmc=\">https://s2.loli.net/2021/12/10/TACsGaltIMWcuV9.png</span>&quot; alt=&quot;image-20211210125021314&quot; style=&quot;zoom: 50%;&quot; /&gt;</p>\n</blockquote>\n</li>\n</ul>\n<p>持久 http: 每个连接发送多个对象 (HTTP/1.1)</p>\n<p>过程</p>\n<ul>\n<li>客户端初始化连接</li>\n<li>服务端接受</li>\n<li>下面步骤 * n\n<ul>\n<li>客户端发送请求</li>\n<li>服务端发送数据</li>\n<li>客户端收到数据</li>\n</ul>\n</li>\n<li>服务端关掉连接</li>\n</ul>\n<p>例子</p>\n<ul>\n<li>\n<blockquote>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwL3JtRW9NU3doVWVLbFFEQy5wbmc=\">https://s2.loli.net/2021/12/10/rmEoMSwhUeKlQDC.png</span>&quot; alt=&quot;image-20211210125349254&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"http请求报文\"><a class=\"anchor\" href=\"#http请求报文\">#</a> HTTP 请求报文</h5>\n<p>两种 type: 请求和响应</p>\n<p>请求报文样式:</p>\n<p>请求行 报头 空白行 正文</p>\n<p>GET /somedir/page.html HTTP/1.1 -- 请求</p>\n<p>Host: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zb21lc2Nob29sLmVkdQ==\">www.someschool.edu</span> User-agent: Mozilla/4.0 Connection: close Accept-language:fr-- 报头</p>\n<h5 id=\"无状态statelessness和cookies\"><a class=\"anchor\" href=\"#无状态statelessness和cookies\">#</a> 无状态 (Statelessness) 和 Cookies</h5>\n<p>无状态 - 服务器不保留有关客户过去请求的任何信息</p>\n<p>Cookies</p>\n<p>一个小文件 / 字符串，使得服务端能够跟踪用户</p>\n<p>实现</p>\n<blockquote>\n<p>在 Http 响应报文上加上 set-cookie 头</p>\n<p>请求报文上加入 cookie 报头</p>\n<p>cookie 文件留在用户本地，用浏览器管理</p>\n<p>在服务端留有后端的服务器存储用户真正信息</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwL2p1c1RDUGN0ekJkcHJTNS5wbmc=\">https://s2.loli.net/2021/12/10/jusTCPctzBdprS5.png</span>&quot; alt=&quot;image-20211210174626429&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n</blockquote>\n<h5 id=\"web缓存-代理服务器\"><a class=\"anchor\" href=\"#web缓存-代理服务器\">#</a> Web 缓存 - 代理服务器</h5>\n<p>目的：缩短对客户请求的响应时间，减少组织接入链路上的流量</p>\n<p>用户浏览器：通过缓存访问网站</p>\n<p>浏览器把所有的 HTTP 响应发送给 cache</p>\n<ul>\n<li>条件 GET<br />\n 如果缓存中有最新缓存版本，就不发送该对象</li>\n</ul>\n</blockquote>\n<h4 id=\"222ftp不考\"><a class=\"anchor\" href=\"#222ftp不考\">#</a> 2.2.2FTP [不考]</h4>\n<h4 id=\"223electronic-mailsmtp-pop3-imap\"><a class=\"anchor\" href=\"#223electronic-mailsmtp-pop3-imap\">#</a> 2.2.3Electronic  Mail——SMTP, POP3, IMAP</h4>\n<p>关键组件:</p>\n<blockquote>\n<p>用户代理</p>\n<ul>\n<li>\n<blockquote>\n<p>邮件阅读者</p>\n<p>撰写，编辑，阅读邮件</p>\n<p>发送 / 接收在 server 上存储的邮件</p>\n</blockquote>\n</li>\n</ul>\n<p>邮件服务器</p>\n<ul>\n<li>\n<blockquote>\n<p>mailbox 保留用户收到的信息</p>\n<p>为发送的邮件信息创建发送队列</p>\n<p>在 server 中间提供 SMTP 协议服务，用来发送邮件</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<p>示意图</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwL0c5NzRDdU5GU2dtSFk2eC5wbmc=\">https://s2.loli.net/2021/12/10/G974CuNFSgmHY6x.png</span>&quot; alt=&quot;image-20211210175052267&quot; style=&quot;zoom:67%;&quot; /&gt;</p>\n<p>邮件发送协议:</p>\n<ul>\n<li>SMTP: 简单邮件传输协议</li>\n<li>MIME: 通用因特网邮件拓展<br />\n SMTP 只能传输 ASCII 码，不能传输二进制数据，MIME 允许二进制数据以 ASCII 编码</li>\n</ul>\n<p>邮件读取协议:</p>\n<ul>\n<li>pop: 邮局协议 Post Office Protocol<br />\n 授权 + 下载</li>\n<li>IMAP: 因特网报文读取协议<br />\n更多功能<br />\n操作存储在服务器上的报文</li>\n<li>HTTP: gmail,Hotmail,Yahoo!Mail</li>\n</ul>\n<h4 id=\"224dns-域名系统\"><a class=\"anchor\" href=\"#224dns-域名系统\">#</a> 2.2.4DNS 域名系统</h4>\n<p>提供的服务</p>\n<blockquote>\n<p>主机名到 ip 的翻译</p>\n<p>主机别名</p>\n<p>邮件服务器错误识别</p>\n<p>负载分配 (即一个主机名对应一组 IP 地址)</p>\n</blockquote>\n<h5 id=\"分布式层次化数据库\"><a class=\"anchor\" href=\"#分布式层次化数据库\">#</a> 分布式层次化数据库</h5>\n<p><img data-src=\"https://s2.loli.net/2021/12/10/KxSiLqzaPj1Hy3Y.png\" alt=\"image-20211210182515156\" /></p>\n<p>访问 www.amazon.com 的过程</p>\n<p>客户 -&gt;root, 得到 com server</p>\n<p>客户 -&gt;com server 得到 <span class=\"exturl\" data-url=\"aHR0cDovL2FtYXpvbi5jb20=\">amazon.com</span> DNS server</p>\n<p>客户 -&gt;<span class=\"exturl\" data-url=\"aHR0cDovL2FtYXpvbi5jb20=\">amazon.com</span> DNS server 得到对应 ip 地址</p>\n<h5 id=\"本地域名服务器\"><a class=\"anchor\" href=\"#本地域名服务器\">#</a> 本地域名服务器</h5>\n<p>大学 / 公司内部搭建</p>\n<p>主机创建 DNS 请求的时候，先送到本地 DNS server</p>\n<h5 id=\"域名解析例子\"><a class=\"anchor\" href=\"#域名解析例子\">#</a> 域名解析例子</h5>\n<blockquote>\n<p><img data-src=\"https://s2.loli.net/2021/12/10/wiEbcMuj5rzRUOF.png\" alt=\"image-20211210183014756\" /></p>\n</blockquote>\n<h5 id=\"dns-protocol\"><a class=\"anchor\" href=\"#dns-protocol\">#</a> DNS Protocol</h5>\n<p>使用 UDP 协议的 53 号端口传输</p>\n<h4 id=\"225p2p不考\"><a class=\"anchor\" href=\"#225p2p不考\">#</a> 2.2.5P2P [不考]</h4>\n<h3 id=\"23网络编程不考\"><a class=\"anchor\" href=\"#23网络编程不考\">#</a> 2.3 网络编程 [不考]</h3>\n<h4 id=\"网络应用程序编程接口-套接字不考\"><a class=\"anchor\" href=\"#网络应用程序编程接口-套接字不考\">#</a> 网络应用程序编程接口 - 套接字 [不考]</h4>\n<h2 id=\"3传输层\"><a class=\"anchor\" href=\"#3传输层\">#</a> 3. 传输层</h2>\n<h3 id=\"31传输层提供的服务\"><a class=\"anchor\" href=\"#31传输层提供的服务\">#</a> 3.1 传输层提供的服务</h3>\n<h4 id=\"311传输层的功能\"><a class=\"anchor\" href=\"#311传输层的功能\">#</a> 3.1.1 传输层的功能</h4>\n<p>为运行在不同主机上的应用进程之间提供逻辑通信</p>\n<ul>\n<li>端到端</li>\n<li>依赖并强化网络层服务</li>\n</ul>\n<h4 id=\"312无连接服务与面向连接服务\"><a class=\"anchor\" href=\"#312无连接服务与面向连接服务\">#</a> 3.1.2 无连接服务与面向连接服务</h4>\n<p>无连接：无握手</p>\n<p>面向连接：数据交换前通过握手初始化发送方与接收方的服务</p>\n<h4 id=\"313传输层寻址与端口\"><a class=\"anchor\" href=\"#313传输层寻址与端口\">#</a> 3.1.3 传输层寻址与端口</h4>\n<p>传输层寻址通过 TCP 和 UDP 的端口实现</p>\n<blockquote>\n<p>TCP/IP:0~65535</p>\n<ul>\n<li>0~ 1023: 标准端口，用于特定服务</li>\n<li>其余临时端口</li>\n</ul>\n</blockquote>\n<p>不同的端口表示不同的应用程序</p>\n<h3 id=\"32无连接的传输协议udp\"><a class=\"anchor\" href=\"#32无连接的传输协议udp\">#</a> 3.2 无连接的传输协议 ——UDP</h3>\n<h5 id=\"特征\"><a class=\"anchor\" href=\"#特征\">#</a> 特征</h5>\n<blockquote>\n<p>尽力而为 (会丢包，顺序会乱)</p>\n<p>无连接 - 没有握手，每个报文的处理<strong>与其他报文独立</strong></p>\n<p>经常被流媒体使用 (能容忍丢包，对时间敏感)</p>\n</blockquote>\n<p>DNS 和 SNMP 是用 UDP 的</p>\n<p>UDP 格式</p>\n<table>\n<thead>\n<tr>\n<th>源端口 (16bit</th>\n<th>目的端口 (16bit)</th>\n<th>长度 (16bit)</th>\n<th>校验和 (16bit)</th>\n<th>报文</th>\n</tr>\n</thead>\n</table>\n<p>UDP 校验和计算</p>\n<p>临时把伪首部 (12 字节 IP 首部) 和数据报连接在一起，用于检验是否在正确的端点之间传送</p>\n<p>计算校验和</p>\n<p>过程</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/10/I9pQY8KlRjohZyA.png\" alt=\"image-20211210184555287\" /></p>\n<p>反码求和</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwL1pxaXRBSUtEOU1oV0ZCWC5wbmc=\">https://s2.loli.net/2021/12/10/ZqitAIKD9MhWFBX.png</span>&quot; alt=&quot;image-20211210184821480&quot; style=&quot;zoom: 67%;&quot; /&gt;</p>\n<p>校验和例子</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwL3BSelNFVEdaakJ2YjRVSS5wbmc=\">https://s2.loli.net/2021/12/10/pRzSETGZjBvb4UI.png</span>&quot; alt=&quot;image-20211210185822703&quot; style=&quot;zoom:67%;&quot; /&gt;</p>\n<h3 id=\"33可靠数据传输的原理\"><a class=\"anchor\" href=\"#33可靠数据传输的原理\">#</a> 3.3 可靠数据传输的原理</h3>\n<p>目的</p>\n<blockquote>\n<p>数据位不被损坏</p>\n<p>没有数据丢失</p>\n<p>数据以发送顺序被传输</p>\n</blockquote>\n<p>总结 - 要在非可靠信道上提供可靠的数据通信</p>\n<p>基础操作</p>\n<blockquote>\n<p>ARQ 自动重传请求：接收方发现错误 / 丢失分组后要求发送方重传</p>\n<p>错误分组检测 - 校验和</p>\n<p>丢失分组 - 确认，超时</p>\n<p>重传 (Retransmit)</p>\n</blockquote>\n<h4 id=\"331停止-等待协议sw\"><a class=\"anchor\" href=\"#331停止-等待协议sw\">#</a> 3.3.1 停止 - 等待协议（SW）</h4>\n<p>发送方发送一个分组后，必须停下来等待接收方确认后才可以发送下一个分组</p>\n<p>错误处理：收到错误分组，接收方发送否定确认，让发送方重发</p>\n<p>丢失处理：发送方内部设置定时器，超过定时时间还未收到 ACK 确认，则重发</p>\n<p>处理重复分组：给每个分组带上序号 (模<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>)</p>\n<h5 id=\"性能分析及计算\"><a class=\"anchor\" href=\"#性能分析及计算\">#</a> 性能分析及计算</h5>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwLzJzbFhxd2JCYTV4OVltOC5wbmc=\">https://s2.loli.net/2021/12/10/2slXqwbBa5x9Ym8.png</span>&quot; alt=&quot;image-20211210190424127&quot; style=&quot;zoom:67%;&quot; /&gt;</p>\n<h4 id=\"332回退n协议gbn\"><a class=\"anchor\" href=\"#332回退n协议gbn\">#</a> 3.3.2 回退 N 协议（GBN）</h4>\n<p>发送方</p>\n<blockquote>\n<p>在收到确认前可以发送多个分组</p>\n<p>发送窗口<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">W_s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 最大为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.747722em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n<p>每发送一个分组后，就启动内部计时器，若超时未收到确认，则重发该分组之后已发送的 N 个分组</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/10/BhjV1KgSrJ6xXiL.png\" alt=\"image-20211210193707525\" /></p>\n</blockquote>\n<p>接收方</p>\n<blockquote>\n<p>接收方只能缓冲一个分组</p>\n<p>接收方只对按序到达的最后一个分组发送确认分组 (因此对乱序分组会产生重复的确认分组)</p>\n</blockquote>\n<p>序号:</p>\n<ul>\n<li>是模 2^n 的，n 是字段的位数</li>\n</ul>\n<h4 id=\"333选择重传协议sr\"><a class=\"anchor\" href=\"#333选择重传协议sr\">#</a> 3.3.3 选择重传协议（SR）</h4>\n<p>避免不必要的重传</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwL1V1eDg5SWRSb1NPWDFWVy5wbmc=\">https://s2.loli.net/2021/12/10/Uux89IdRoSOX1VW.png</span>&quot; alt=&quot;image-20211210194222054&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>接收方</p>\n<blockquote>\n<p>接逐个确认接收到的每一个分组</p>\n<p>发现某个分组出错后，其后继续送来的正确分组还是被接收，放在缓冲区中，同时要求发送方重新传送出错分组</p>\n</blockquote>\n<p>发送方</p>\n<blockquote n-1=\"\">\n<p>只有在接收窗口向前滑动时，发送窗口才有可能向前滑动</p>\n<p>即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>S</mi></msub><mo>&gt;</mo><mo>=</mo><msub><mi>W</mi><mi>R</mi></msub></mrow><annotation encoding=\"application/x-tex\">W_S&gt;=W_R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 且 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>s</mi></msub><mo>+</mo><msub><mi>W</mi><mi>R</mi></msub><mo>&lt;</mo><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">W_s+W_R&lt;=2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></p>\n<p>窗口长度 &lt;=2^</p>\n</blockquote>\n<h4 id=\"334滑动窗口机制可用于实现不同可靠传输协议\"><a class=\"anchor\" href=\"#334滑动窗口机制可用于实现不同可靠传输协议\">#</a> 3.3.4 滑动窗口机制（可用于实现不同可靠传输协议）</h4>\n<p>流水线协议 / 连续 ARQ (也叫 &lt; u&gt; 滑动窗口协议 &lt;/u&gt;)</p>\n<p>当发送端等待确认时，我们需要传输多个分组来提高利用率</p>\n<p>Pipeling: 允许发送方发送多个未被确认的分组</p>\n<p>概念</p>\n<blockquote>\n<p>发送窗口：发送方在没收到确认的情况下，能够连续发送的分组的序号表<br />\n &lt; img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwL3dnalR4NWMzYXFyQ29IRC5wbmc=\">https://s2.loli.net/2021/12/10/wgjTx5c3aqrCoHD.png</span>&quot; alt=&quot;image-20211210191530175&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<ul>\n<li>大小:<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>s</mi></msub></mrow><annotation encoding=\"application/x-tex\">W_s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">s</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></li>\n<li>下界表示未得到确认的分组的最小序号</li>\n</ul>\n<p>接收窗口：希望接收的分组的序号表<br />\n<img data-src=\"https://s2.loli.net/2021/12/10/hmAcMeU8rnJSRo6.png\" alt=\"image-20211210191655633\" /></p>\n<ul>\n<li>大小<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>R</mi></msub></mrow><annotation encoding=\"application/x-tex\">W_R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></li>\n<li>上界表示允许接收的分组的最大序号，下界表示希望接收的下一个分组的序号</li>\n<li>若序号等于下界的分组被正确接收，并发送一个确认分组，上下界都加 1, 接收窗口向前滑动一次</li>\n</ul>\n</blockquote>\n<h3 id=\"34面向连接的传输协议-tcp\"><a class=\"anchor\" href=\"#34面向连接的传输协议-tcp\">#</a> 3.4 面向连接的传输协议 ——  TCP</h3>\n<h5 id=\"总览\"><a class=\"anchor\" href=\"#总览\">#</a> 总览</h5>\n<blockquote>\n<p>点到点</p>\n<p>可靠有序的字节流 - 没有报文边界</p>\n<p>流水线 - 拥塞控制和流量控制设置窗口大小</p>\n<p>全双工数据 - 双方可以同时发送和接收</p>\n<blockquote>\n<p>要求每一端都有两个窗口</p>\n</blockquote>\n<p>流量控制</p>\n<p>面向连接</p>\n<p>拥塞控制</p>\n</blockquote>\n<h4 id=\"341tcp报文段\"><a class=\"anchor\" href=\"#341tcp报文段\">#</a> 3.4.1TCP 报文段</h4>\n<h5 id=\"结构\"><a class=\"anchor\" href=\"#结构\">#</a> 结构</h5>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwL0NTTUpkaGplSVByT0hMbS5wbmc=\">https://s2.loli.net/2021/12/10/CSMJdhjeIPrOHLm.png</span>&quot; alt=&quot;image-20211210194733680&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>解释</p>\n<ul>\n<li>\n<p>源端口和目的端口 - 2 字节 /each,</p>\n</li>\n<li>\n<p>序号 - 每字节都有序号，序号字段存储发送字节的第一个的序号</p>\n</li>\n<li>\n<p>确认号 - 希望收到下一个保温段的数据的第一个字节的序号<br />\n TCP 使用累积确认</p>\n</li>\n<li>\n<p>一些特殊位</p>\n<blockquote>\n<p>URG - 紧急</p>\n<p>ACK-1 时确认号字段有效</p>\n<p>PSH - 尽快交付 (不等待缓存写满)</p>\n<p>RST-reset 复位，重新建立连接</p>\n<p>SYN - 如果为 1 表示这是个连接请求</p>\n<p>FIN-1 的话释放连接</p>\n</blockquote>\n</li>\n<li>\n<p>校验和 - 检验首部和数据</p>\n</li>\n</ul>\n<h4 id=\"342tcp可靠传输\"><a class=\"anchor\" href=\"#342tcp可靠传输\">#</a> 3.4.2TCP 可靠传输</h4>\n<p>用字节序号进行控制</p>\n<p>过程模拟</p>\n<blockquote>\n<p>B 给出通告窗口值 20-&gt;A 构造长为 20 的发送窗口 (31~50)</p>\n<p>A 发送 11 字节数据，此时还剩 9 字节可被发送</p>\n<p>B 接收窗口也为 20, 收到 3 字节，发送确认号 33-&gt;A 窗口移动到 (34~53)</p>\n<p>B 窗口也滑动到 34</p>\n</blockquote>\n<p>重传计时器 ***</p>\n<p>四个窗口 (两发两收) 动态变化</p>\n<h4 id=\"343tcp流量控制\"><a class=\"anchor\" href=\"#343tcp流量控制\">#</a> 3.4.3TCP 流量控制</h4>\n<p>目的：让发送方速率不要太快，让接收方来得及接收</p>\n<p>利用滑动窗口机制实现</p>\n<p>如果接收端顶不住发送端了，缓冲区被全部占用，就只能发送一个零通告窗口</p>\n<p>发送端收到零通告窗口后停止发送，直到等到接收端发送一个非零的通告窗口</p>\n<ul>\n<li>持续计时器<br />\n收到零通告窗口时启动，如果持续时间到期，就发送一个探测报文段，请求一个对方的通告窗口<br />\n如果还是零，就重设计时器</li>\n</ul>\n<h4 id=\"344tcp连接管理不考\"><a class=\"anchor\" href=\"#344tcp连接管理不考\">#</a> 3.4.4TCP 连接管理 [不考]</h4>\n<h4 id=\"345tcp拥塞控制\"><a class=\"anchor\" href=\"#345tcp拥塞控制\">#</a> 3.4.5TCP 拥塞控制</h4>\n<p>太多的源太快地发送太多的数据，使网络来不及处理</p>\n<p>表现：丢包 (路由器缓冲区溢出)</p>\n<p>长时延 (缓冲区中排队)</p>\n<p>作用：提高吞吐量</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/10/UMDJeWx3bX9QsZR.png\" alt=\"image-20211210202844398\" /></p>\n<h5 id=\"与流量控制的区别\"><a class=\"anchor\" href=\"#与流量控制的区别\">#</a> 与流量控制的区别</h5>\n<blockquote>\n<p>拥塞控制</p>\n<ul>\n<li>需要确保通信子网能够承载用户提交的通信两，是一个全局性过程，涉及主机，路由器等很多因素</li>\n</ul>\n<p>流量控制</p>\n<ul>\n<li>与点到点的通信量有关，主要解决快速发送方与慢速发送方的问题，是局部过程</li>\n</ul>\n</blockquote>\n<h5 id=\"拥塞控制方法\"><a class=\"anchor\" href=\"#拥塞控制方法\">#</a> 拥塞控制方法</h5>\n<p>发送方维持一个拥塞窗口 cwnd, 其大小取决于网络拥塞程度，且动态变化</p>\n<blockquote>\n<p>网络不堵塞，拥塞窗口增大一些</p>\n<p>堵塞就把它减少一些</p>\n</blockquote>\n<p>发送方发送窗口的上限为接收方通告窗口 [rwnd] 和拥塞窗口 [cwnd] 中较小的一个</p>\n<p>四种办法</p>\n<blockquote>\n<ol>\n<li>\n<p>慢开始 / 启动<br />\n cwnd 初始化为 1<br />\n 每收到一个对应确认，cwnd+=1<br />\n<img data-src=\"https://s2.loli.net/2021/12/10/Z7juwLIF8U69mBy.png\" alt=\"image-20211210203322561\" /><br />\n 每经过一个传输轮次，cwnd*=2, 时间为 RTT</p>\n</li>\n<li>\n<p>拥塞避免<br />\n每经过一个 RTT, 拥塞窗口 + 1, 缓慢增长</p>\n<ul>\n<li>\n<p>慢开始门限 ssthresh</p>\n<blockquote>\n<p>cwnd&lt;ssthresh -&gt; 慢开始 / 慢启动算法</p>\n<p>cwnd&gt;ssthresh -&gt; 拥塞避免</p>\n<p>cwnd=ssthresh -&gt; 都行</p>\n</blockquote>\n<p>实现举例<br />\n &lt; img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwL3JLYUNucVQzdFJieGQ0bS5wbmc=\">https://s2.loli.net/2021/12/10/rKaCnqT3tRbxd4m.png</span>&quot; alt=&quot;image-20211210203723811&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>出现拥塞时</p>\n<blockquote>\n<p>把 ssthresh 设置为当前值的一半</p>\n<p>把 cwnd 重设为 1</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>快重传<br />\n要求接收方每收到一个失序的报文段后立即发出重复确认<br />\n发送方一连收到三个重复确认就立即重传未收到报文段</p>\n</li>\n<li>\n<p>快恢复<br />\n当发送端收到连续三个重复确认时，把 ssthresh 设置为当前一半，但接下去不执行慢开始 / 慢启动算法，而是将 cwnd 设置为 ssthresh 减半后数值，然后开始执行拥塞避免算法<br />\n &lt; img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwLzNvVFhHQms0VmR2QVF1Zi5wbmc=\">https://s2.loli.net/2021/12/10/3oTXGBk4VdvAQuf.png</span>&quot; alt=&quot;image-20211210204852460&quot; style=&quot;zoom:67%;&quot; /&gt;</p>\n</li>\n</ol>\n</blockquote>\n<h2 id=\"4网络层\"><a class=\"anchor\" href=\"#4网络层\">#</a> 4. 网络层</h2>\n<h3 id=\"41网络层的功能\"><a class=\"anchor\" href=\"#41网络层的功能\">#</a> 4.1 网络层的功能</h3>\n<p>在发送端，将分组封装成数据报</p>\n<p>在接收端，把数据报上传到传输层</p>\n<p>路由器检查每个通过它的数据报</p>\n<h5 id=\"两个关键功能\"><a class=\"anchor\" href=\"#两个关键功能\">#</a> 两个关键功能</h5>\n<blockquote>\n<p>转发 - 将分组从路由器的输入端口移动到输出端口</p>\n<p>路由 - 决定分组从源主机到目的主机所采用的设备</p>\n</blockquote>\n<h5 id=\"网络层服务模型我觉得没什么考的必要\"><a class=\"anchor\" href=\"#网络层服务模型我觉得没什么考的必要\">#</a> 网络层服务模型 (我觉得没什么考的必要)</h5>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzEwLzdTc3dDMnFGUWhnQjNvZC5wbmc=\">https://s2.loli.net/2021/12/10/7SswC2qFQhgB3od.png</span>&quot; alt=&quot;image-20211210212419693&quot; style=&quot;zoom:67%;&quot; /&gt;</p>\n<h3 id=\"42网络层设备\"><a class=\"anchor\" href=\"#42网络层设备\">#</a> 4.2 网络层设备</h3>\n<h4 id=\"路由器\"><a class=\"anchor\" href=\"#路由器\">#</a> 路由器</h4>\n<h5 id=\"输入端口\"><a class=\"anchor\" href=\"#输入端口\">#</a> 输入端口</h5>\n<blockquote>\n<p>物理层 - 比特级接收</p>\n<p>链路层连接以太网</p>\n<p>最后一层进行分散式交换 - 给定数据报目的地址，在输入端口中使用转发表查找输出端口<br />\n - 到达较快的话还会排队</p>\n</blockquote>\n<p>三种类型交换结构</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzExL1JxMmp5WnBKYkg0aTlBTy5wbmc=\">https://s2.loli.net/2021/12/11/Rq2jyZpJbH4i9AO.png</span>&quot; alt=&quot;image-20211211103137804&quot; style=&quot;zoom:67%;&quot; /&gt;</p>\n<p>输出端口</p>\n<blockquote>\n<p>当数据报来自比传输速率更快的交换结构时，需要 **&lt;u&gt; 缓存 &lt;/u&gt;**</p>\n<p>&lt;u&gt;<strong> 调度安排</strong> &lt;/u&gt;- 在排队的数据报中选择要传输的数据报</p>\n</blockquote>\n<h3 id=\"43ip\"><a class=\"anchor\" href=\"#43ip\">#</a> 4.3IP</h3>\n<p>链路层之上，传输层之下</p>\n<h4 id=\"431ipv4分组\"><a class=\"anchor\" href=\"#431ipv4分组\">#</a> 4.3.1IPv4 分组</h4>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzExL1ZJeVFTZktvbUxUSmkxRS5wbmc=\">https://s2.loli.net/2021/12/11/VIyQSfKomLTJi1E.png</span>&quot; alt=&quot;image-20211211103434802&quot; style=&quot;zoom: 50%;&quot; /&gt;</p>\n<h5 id=\"首部字段解释\"><a class=\"anchor\" href=\"#首部字段解释\">#</a> 首部字段解释</h5>\n<blockquote>\n<p>总长度 - 首部和数据之和的长度，最大为 65535</p>\n<p>标识 - 计数器，产生数据报标识</p>\n<p>标志 - 3bit, 最低位 (M (ore) F (ragment) 等于一代表还有分片，等于 0 代表没有分片，<br />\n 中间一位 = 0 才允许分片 (D (ont) F (ragment))</p>\n<p>片偏移 - 13bit, 指出分片后该片在原分组中的相对位置，以 8 个字节为偏移单位</p>\n<h5 id=\"ip分片和重组\"><a class=\"anchor\" href=\"#ip分片和重组\">#</a> IP 分片和重组</h5>\n<p>为什么分片 - 链路有最大传输单元，不同链路 MTU 不同</p>\n<p>样例</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzExLzd6dUhLTUVBQlAxanBYOS5wbmc=\">https://s2.loli.net/2021/12/11/7zuHKMEABP1jpX9.png</span>&quot; alt=&quot;image-20211211104103771&quot; style=&quot;zoom:67%;&quot; /&gt;</p>\n<p>生存时间 (TTL time to live) 限制数据报在网络中的生存时间，每经过一个路由器，TTL-1</p>\n<p>协议 - 数据部分协议 (TCP/UDP/IPV6 等等) 不一定是 &lt; u &gt; 上层，&lt;/u&gt;</p>\n<p>首部校验和 - 只检验首部</p>\n<blockquote>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/5hrMJg1ezbuwcG4.png\" alt=\"image-20211211104807155\" /></p>\n</blockquote>\n</blockquote>\n<h4 id=\"432ipv4地址\"><a class=\"anchor\" href=\"#432ipv4地址\">#</a> 4.3.2IPv4 地址</h4>\n<p>ip 地址 - 32 位的主机 / 交换机标识号</p>\n<p>接口 interface - 主机 / 路由器与物理链路之间的链接</p>\n<blockquote>\n<p>交换机有很多个 interface</p>\n<p>主机一般就一两个</p>\n<p>Ip 地址与每个接口相关联</p>\n</blockquote>\n<h5 id=\"子网\"><a class=\"anchor\" href=\"#子网\">#</a> 子网</h5>\n<p>设备接口 Ip 地址的子网部分相同</p>\n<p>可以物理上直接联系，不用经过交换机</p>\n<h5 id=\"计算可用的主机地址\"><a class=\"anchor\" href=\"#计算可用的主机地址\">#</a> 计算可用的主机地址</h5>\n<p>主机部分全 0: 网络地址</p>\n<p>主机部分全 1: 广播地址</p>\n<p>上两个不能设置为主机地址</p>\n<h5 id=\"子网掩码\"><a class=\"anchor\" href=\"#子网掩码\">#</a> 子网掩码</h5>\n<p>/n 表示子网掩码位数为 n</p>\n<p>x.y.z.a, 点分十进制形式表示 32bit IP 地址中哪些事子网部分</p>\n<h5 id=\"ip地址分配方案\"><a class=\"anchor\" href=\"#ip地址分配方案\">#</a> IP 地址分配方案</h5>\n<ol>\n<li>\n<p>子网位数固定 - 分类 IP 地址</p>\n</li>\n<li>\n<p>不固定 --CIDR (无类域间路由)</p>\n<blockquote>\n<p>子网部分被称为网络前缀，前缀部分任意长</p>\n<p>使用斜线记法</p>\n<p>路由表中每个项目由 &quot;网络前缀&quot; 和 &quot;下一跳地址&quot; 组成，查找路由表时可能会得到不止一个匹配结果，因此引出下面内容</p>\n<h6 id=\"最长前缀匹配\"><a class=\"anchor\" href=\"#最长前缀匹配\">#</a> 最长前缀匹配</h6>\n<p>举例</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/l9C2phSQBAz4OHm.png\" alt=\"image-20211211134931698\" /></p>\n<h6 id=\"cidr子网划分\"><a class=\"anchor\" href=\"#cidr子网划分\">#</a> CIDR 子网划分 ***</h6>\n<p>把一个大网络分成多个小网络，用路由器把这些小网络连接起来</p>\n<blockquote>\n<p>使用子网掩码 255.255.255.192 (/26) 对网络<br />\n 192.168.10.0/24 进行子网划分，请回答如下问题 :<br />\n– (1) 子网数？</p>\n<p>192 为二进制 11000000，即 22 = 4 个子网；</p>\n<p>– (2) 每个子网中可以容纳的主机数？</p>\n<p>26 -2 =62 个主机；</p>\n<p>– (3) 哪些是合法的子网地址？</p>\n<p>每个子网的地址块大小为 26 =64，子<br />\n网地址的第 4 个字节从 0 开始以 64 递增，即：192.168.10.0、<br />\n192.168.10.64、192.168.10.128、192.168.10.192</p>\n<p>– (4) 每个子网的广播地址？</p>\n<p>– (5) 哪些是合法的主机地址？</p>\n<p>子网地址 (192.168.10.) 0 64 128 192<br />\n 第一个主机地址 (192.168.10.) 1 65 129 193<br />\n 最后一个主机地址 (192.168.10.) 62 126 190 254<br />\n 广播地址 (192.168.10.) 63 127 191 255</p>\n</blockquote>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"433ip分组转发\"><a class=\"anchor\" href=\"#433ip分组转发\">#</a> 4.3.3IP 分组转发</h4>\n<p>网络层基于目的地址分组转发</p>\n<p>下图一了百了</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/vrUGaPkfJExzdCZ.png\" alt=\"image-20211211140706891\" /></p>\n<p>转发算法</p>\n<blockquote>\n<ol>\n<li>\n<p>从收到分组的首部获得目的 IP-&gt;<strong>D</strong></p>\n</li>\n<li>\n<p>判断是否在同一网络上</p>\n<blockquote>\n<p>用子网掩码和<strong> D</strong> 逐位相与，看看是不是和 **&lt;u&gt; 相应的网络地址 &lt;/u&gt;** 匹配，匹配就直接发过去</p>\n</blockquote>\n</li>\n<li>\n<p>若路由表中有目的为 D 的<strong>特定主机路由</strong>，则将分组传送给指明的下一跳路由器，<br />\n 否则执行 4</p>\n</li>\n<li>\n<p>对路由表每行的子网掩码和 D 逐位相与，若结果与该行的目的网络地址匹配，就传送到下一跳<br />\n否则，执行 5</p>\n</li>\n<li>\n<p>若路由表有默认路由，则将其传送给它，<br />\n 否则执行 6</p>\n</li>\n<li>\n<p>报告转发分组出错</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"434dhcp动态主机配置协议协议\"><a class=\"anchor\" href=\"#434dhcp动态主机配置协议协议\">#</a> 4.3.4DHCP (动态主机配置协议) 协议</h4>\n<p>Q.A</p>\n<blockquote>\n<p>主机如何获得 IP 地址</p>\n<ul>\n<li>管理员硬编码</li>\n</ul>\n<p>网络怎样得到 IP 地址的子网</p>\n<ul>\n<li>从其 ISP 的地址空间中得到分配的部分</li>\n</ul>\n<p>ISP 如何获得地址块</p>\n<ul>\n<li>ICANN (因特网名字与号码分配公司)</li>\n</ul>\n</blockquote>\n<h6 id=\"dhcp目的-使主机能够动态获取服务器的ip地址当它加入网络时\"><a class=\"anchor\" href=\"#dhcp目的-使主机能够动态获取服务器的ip地址当它加入网络时\">#</a> DHCP 目的：使主机能够动态获取服务器的 IP 地址 (当它加入网络时)</h6>\n<p>示意图</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/nlAa7d6vSw4V5qH.png\" alt=\"image-20211211142745600\" /></p>\n<h4 id=\"435nat不考\"><a class=\"anchor\" href=\"#435nat不考\">#</a> 4.3.5NAT [不考]</h4>\n<h4 id=\"436ipv6不考\"><a class=\"anchor\" href=\"#436ipv6不考\">#</a> 4.3.6IPv6 [不考]</h4>\n<h3 id=\"44路由算法\"><a class=\"anchor\" href=\"#44路由算法\">#</a> 4.4 路由算法</h3>\n<blockquote>\n<p>路由算法用于选择从源主机到目的主机的最佳路径</p>\n<p>是产生路由表的算法 (找到开销最小的路径)</p>\n<p>分类</p>\n<blockquote>\n<p>静态路由：路由随时间缓慢变化</p>\n<p>动态路由：更快地变化，周期性更新，适应链路开销变化</p>\n</blockquote>\n</blockquote>\n<h4 id=\"441距离向量路由算法\"><a class=\"anchor\" href=\"#441距离向量路由算法\">#</a> 4.4.1 距离向量路由算法</h4>\n<h5 id=\"bellman-ford方程\"><a class=\"anchor\" href=\"#bellman-ford方程\">#</a> Bellman-Ford 方程</h5>\n<blockquote>\n<p>定义<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>x</mi></msub><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">d_x(y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span>= 从 x 到 y 的最小开销路径的开销</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">c(x,v)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span></span></span></span>= 从 x 到邻居节点 v 的链路的开销</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>x</mi></msub><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>v</mi></msub><mo stretchy=\"false\">{</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>v</mi><mo stretchy=\"false\">)</mo><mo>+</mo><msub><mi>d</mi><mi>v</mi></msub><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">d_x(y)=min_v\\{c(x,v)+d_v(y)\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mclose\">}</span></span></span></span> ,min 针对 x 的所有邻居</p>\n</blockquote>\n<p>取值最小的结点对应最短路径中的下一跳 -&gt; 转发表</p>\n<h5 id=\"过程\"><a class=\"anchor\" href=\"#过程\">#</a> 过程</h5>\n<blockquote>\n<p>结点 x 维护距离向量<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>x</mi></msub><mo>=</mo><mo stretchy=\"false\">[</mo><msub><mi>d</mi><mi>x</mi></msub><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>:</mo><mi>y</mi><mo>∈</mo><mi>N</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">D_x=[d_x(y):y\\in N]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7335400000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">]</span></span></span></span></p>\n<ul>\n<li>如果 y 不是 x 的邻居，则<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>x</mi></msub><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi mathvariant=\"normal\">∞</mi><mo separator=\"true\">,</mo><mtext>否则</mtext><msub><mi>d</mi><mi>x</mi></msub><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>y</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">d_x(y)=\\infin,否则d_x(y)=c(x,y)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">∞</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord cjk_fallback\">否</span><span class=\"mord cjk_fallback\">则</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>每个节点周期性向邻居节点发送自己的距离向量，节点 x 保存其邻居节点的距离向量</p>\n<p>当结点 x 收到来自邻居的新距离向量，它使用 B-F 方程更新自己的 DV</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>D</mi><mi>x</mi></msub><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo>←</mo><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>v</mi></msub><mo stretchy=\"false\">{</mo><mi>c</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>v</mi><mo>+</mo><msub><mi>D</mi><mi>v</mi></msub><mo stretchy=\"false\">(</mo><mi>y</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">}</mo><mi>f</mi><mi>o</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>y</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">D_x(y)\\gets min_v\\{c(x,v+D_v(y)\\} for each node y\\in N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">←</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">c</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">v</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mclose\">)</span><span class=\"mclose\">}</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">y</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></li>\n</ul>\n</blockquote>\n<p>示例</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/x75AVi8BThZJcHy.png\" alt=\"image-20211211144152548\" /></p>\n<h4 id=\"444链路状态路由算法\"><a class=\"anchor\" href=\"#444链路状态路由算法\">#</a> 4.4.4 链路状态路由算法</h4>\n<blockquote>\n<ol>\n<li>发现邻居，学习网络地址</li>\n<li>测量到每一个邻居的时延</li>\n<li>构造一个分组来通告学习到的信息</li>\n<li>向所有路由器发哦送分组</li>\n<li>计算到其他路由器的最短路径</li>\n</ol>\n</blockquote>\n<h5 id=\"使用dijkstra算法计算最短路径\"><a class=\"anchor\" href=\"#使用dijkstra算法计算最短路径\">#</a> 使用 Dijkstra 算法计算最短路径</h5>\n<p>循环:</p>\n<blockquote>\n<p>从可达节点中找到最近的，加入当前节点组</p>\n<p>更新其他节点距离</p>\n<p>当当前节点组为全部节点时退出</p>\n</blockquote>\n<h3 id=\"45路由协议\"><a class=\"anchor\" href=\"#45路由协议\">#</a> 4.5 路由协议</h3>\n<p>目的：使路由选择是可计算的</p>\n<blockquote>\n<p>有巨量的 router</p>\n</blockquote>\n<ul>\n<li>构建自治系统<br />\n自治系统内 OSPF<br />\n 自治系统间 BGP</li>\n</ul>\n<h4 id=\"451ospfopen-shortest-path-first\"><a class=\"anchor\" href=\"#451ospfopen-shortest-path-first\">#</a> 4.5.1OSPF(Open Shortest Path First)</h4>\n<p>开放最短路径优先</p>\n<p>使用 &lt;u&gt; 链路状态算法 &lt;/u&gt;</p>\n<p>通告散布到整个自治系统</p>\n<h5 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点</h5>\n<ul>\n<li>\n<p>安全性 - 所有 OSPF 信息经过鉴别</p>\n</li>\n<li>\n<p>允许使用多条开销相同的路径</p>\n</li>\n<li>\n<p>对每条链路，为不同的服务类型设置多种开销度量</p>\n</li>\n<li>\n<p>集成的单播和多播支持</p>\n</li>\n<li>\n<p>在大域中使用层次 OSPF</p>\n<blockquote>\n<h6 id=\"层次ospf\"><a class=\"anchor\" href=\"#层次ospf\">#</a> 层次 OSPF</h6>\n<ul>\n<li>两级层次 - 本地 + 主干<br />\n仅在本地通告链路状态<br />\n每个节点具有详细的区域拓扑<br />\n仅知道其他区域中网络的方向</li>\n<li>区域边界路由器<br />\n总结到自己区域中网络的距离，向其他区域的边界路由器通告</li>\n<li>主干路由器<br />\n在主干范围内运行 OSPF 路由</li>\n<li>边界路由器<br />\n连接到其他自治系统</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"报文格式\"><a class=\"anchor\" href=\"#报文格式\">#</a> 报文格式</h5>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/amGulnPEFWbYLeS.png\" alt=\"image-20211211150427755\" /></p>\n<h4 id=\"452bgp\"><a class=\"anchor\" href=\"#452bgp\">#</a> 4.5.2BGP</h4>\n<p>Border Gateway Protocol 边界网关协议</p>\n<p>提供功能</p>\n<blockquote>\n<ol>\n<li>eBGP: 从相邻 AS (自治系统) 获得子网可达性信息</li>\n<li>iBGP: 向 AS 内部的所有路由器传播可达性信息<br />\n如下图<br />\n &lt; img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzExL29Kd2c2S05VY3Z1cjhJWS5wbmc=\">https://s2.loli.net/2021/12/11/oJwg6KNUcvur8IY.png</span>&quot; alt=&quot;image-20211211150833119&quot; style=&quot;zoom:50%;&quot; /&gt;</li>\n<li>根据可达性信息和策略，决定到子网的 &quot;好&quot; 路由</li>\n</ol>\n</blockquote>\n<p>允许子网向因特网其余部分通告它的存在</p>\n<p>两个 BGP 路由器通过半永久 TCP 连接交换 BGP 报文</p>\n<p>两个重要的属性</p>\n<blockquote>\n<p>AS-PATH</p>\n</blockquote>\n<h3 id=\"46icmp协议不考\"><a class=\"anchor\" href=\"#46icmp协议不考\">#</a> 4.6ICMP 协议 [不考]</h3>\n<h3 id=\"47snmp协议不考\"><a class=\"anchor\" href=\"#47snmp协议不考\">#</a> 4.7SNMP 协议 [不考]</h3>\n<h2 id=\"5-数据链路层\"><a class=\"anchor\" href=\"#5-数据链路层\">#</a> 5. 数据链路层</h2>\n<h3 id=\"51数据链路层的功能\"><a class=\"anchor\" href=\"#51数据链路层的功能\">#</a> 5.1 数据链路层的功能</h3>\n<blockquote>\n<p>将数据报从一个节点经过一条链路传输到相邻节点</p>\n<p>组帧 - 将数据报封装进帧，加上首部和尾部</p>\n<p>链路接入 - 控制信道接入</p>\n<p>相邻节点间可靠交付</p>\n<p>检错</p>\n<p>纠错</p>\n</blockquote>\n<h3 id=\"52差错控制\"><a class=\"anchor\" href=\"#52差错控制\">#</a> 5.2 差错控制</h3>\n<p>通过通信信道接收的数据和发送的数据不一致的现象 - 传输差错，简称差错</p>\n<h4 id=\"521检错编码\"><a class=\"anchor\" href=\"#521检错编码\">#</a> 5.2.1 检错编码</h4>\n<p>检错</p>\n<blockquote>\n<p>接收方能够推断发生了错误，要求重传</p>\n<p>用于高可靠信道 - 光纤</p>\n<ul>\n<li>\n<p>单比特奇偶校验</p>\n<blockquote>\n<p>增加冗余位使码字中 1 的个数恒为奇数 / 偶数</p>\n<p>能够检测 &lt;u&gt; 奇数个 &lt;/u &gt; 比特差错</p>\n<p>分为垂直奇偶校验和水平奇偶校验</p>\n</blockquote>\n</li>\n<li>\n<p>因特网校验和</p>\n</li>\n<li>\n<p>循环冗余校验<br />\n直接看例子</p>\n</li>\n<li>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/zCrwOTbYQKoB2cq.png\" alt=\"image-20211211155209760\" /></p>\n</li>\n<li>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/xNYocvzXsdl7ViL.png\" alt=\"image-20211211155153041\" /></p>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"522纠错编码不考\"><a class=\"anchor\" href=\"#522纠错编码不考\">#</a> 5.2.2 纠错编码 [不考]</h4>\n<p>纠错</p>\n<blockquote>\n<p>接收方能够推断发送过来的原始数据是什么</p>\n<p>用于易出错信道</p>\n<ul>\n<li>二维奇偶校验 - 能够检测并纠正单比特</li>\n</ul>\n</blockquote>\n<h3 id=\"53介质访问控制\"><a class=\"anchor\" href=\"#53介质访问控制\">#</a> 5.3 介质访问控制</h3>\n<h4 id=\"531信道划分\"><a class=\"anchor\" href=\"#531信道划分\">#</a> 5.3.1 信道划分</h4>\n<p>将信道划分为较小的片</p>\n<h5 id=\"时分多路复用tdm\"><a class=\"anchor\" href=\"#时分多路复用tdm\">#</a> 时分多路复用 TDM</h5>\n<p>将时间划分为一段段等长的时分复用帧，每个用户在每个镇中占用固定序号的时隙</p>\n<p>一目了然</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/ft9ioG7zkQbJyeS.png\" alt=\"image-20211211182642055\" /></p>\n<h5 id=\"频分多路复用fdm\"><a class=\"anchor\" href=\"#频分多路复用fdm\">#</a> 频分多路复用 FDM</h5>\n<p>用户分配到频带后，在通信过程中始终占用该频带</p>\n<p>不同用户同时间占用不同的 (频率) 带宽资源</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/xsLCh2dnT7yPcBR.png\" alt=\"image-20211211182751192\" /></p>\n<h5 id=\"波分多路复用wdm\"><a class=\"anchor\" href=\"#波分多路复用wdm\">#</a> 波分多路复用 WDM</h5>\n<p>就是光纤上的频分多路复用</p>\n<h5 id=\"码分多路复用cdma\"><a class=\"anchor\" href=\"#码分多路复用cdma\">#</a> 码分多路复用 CDMA</h5>\n<ul>\n<li>\n<p>用于无线广播信道中</p>\n</li>\n<li>\n<p>为每个用户分配唯一的码型，所有用户共享相同的频率，但每个用户用自己的码片序列对数据进行编码</p>\n</li>\n<li>\n<p>抗干扰 / 抗发现性较好</p>\n</li>\n<li>\n<p>编码信号 =(原始数据) X (码片序列)</p>\n</li>\n<li>\n<p>解码 = 编码信号和码片序列的内积</p>\n</li>\n</ul>\n<h6 id=\"码片序列\"><a class=\"anchor\" href=\"#码片序列\">#</a> 码片序列</h6>\n<p>每一比特时间划分为一个唯一的 m bit 码片序列</p>\n<blockquote>\n<p>要发送 1, 则发送码片序列<br />\n发送 0, 则发送二进制反码</p>\n</blockquote>\n<h6 id=\"码片序列的正交关系\"><a class=\"anchor\" href=\"#码片序列的正交关系\">#</a> 码片序列的正交关系</h6>\n<p>两个不同站的码片序列正交</p>\n<p>也就是说，二者规格化内积为 0 (每位相互乘累积后为 0)</p>\n<h6 id=\"工作原理\"><a class=\"anchor\" href=\"#工作原理\">#</a> 工作原理</h6>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/CtEYRu6b4eZy9BV.png\" alt=\"image-20211211183405643\" /></p>\n<h4 id=\"532随机访问\"><a class=\"anchor\" href=\"#532随机访问\">#</a> 5.3.2 随机访问</h4>\n<p>不划分信道，允许冲突，全速率传输</p>\n<p>从冲突中恢复</p>\n<h6 id=\"时隙alohaslotted-aloha-极限37效率\"><a class=\"anchor\" href=\"#时隙alohaslotted-aloha-极限37效率\">#</a> 时隙 ALOHA (slotted ALOHA)- 极限 37% 效率</h6>\n<p>假设</p>\n<blockquote>\n<p>所有帧长度相同</p>\n<p>时间划分为等长间隙，能传输一个帧</p>\n<p>结点仅在时隙开始时开始传输帧</p>\n<p>如果 2 + 结点同时传输，所有结点检测到冲突</p>\n</blockquote>\n<p>工作原理</p>\n<blockquote>\n<p>有新帧，在下一个时隙传输</p>\n<p>无冲突，直接发送</p>\n<p>有冲突，在之后的每个后继时隙中以概率 p 重新传送</p>\n</blockquote>\n<h6 id=\"纯alohapure-aloha-极限18效率\"><a class=\"anchor\" href=\"#纯alohapure-aloha-极限18效率\">#</a> 纯 ALOHA (pure ALOHA)- 极限 18% 效率</h6>\n<p>削弱版时隙 ALOHA</p>\n<p>帧到达立马传输，有冲突则等待一段随机时间开始传输</p>\n<h6 id=\"csma-载波侦听多路访问\"><a class=\"anchor\" href=\"#csma-载波侦听多路访问\">#</a> CSMA 载波侦听多路访问</h6>\n<p>思想</p>\n<blockquote>\n<p>在传输前侦听</p>\n<ul>\n<li>信道空闲：传输整个帧</li>\n<li>信道忙；推迟传输 (下列三种推迟策略)\n<ol>\n<li>等待信道空闲 (1 - 坚持)</li>\n<li>等待随机时间 (非坚持)</li>\n<li>等待空闲，然后概率 p 发送 (p - 坚持)</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<p>传播时延的冲突</p>\n<blockquote>\n<p>信道非真正空闲</p>\n<p>争用期 / 冲突窗口：端到端往返时延 2<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi></mrow><annotation encoding=\"application/x-tex\">\\tau</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span></span></span></span></p>\n<p>只有争用期没检测到冲突才能肯定此次发送不会产生冲突</p>\n<p>每个发送数据帧的结点，需要经过争用期才能确保这次发送不会产生冲突</p>\n</blockquote>\n<h6 id=\"csmacd-载波侦听多路访问冲突检测\"><a class=\"anchor\" href=\"#csmacd-载波侦听多路访问冲突检测\">#</a> CSMA/CD 载波侦听多路访问 + 冲突检测</h6>\n<p>CD:Collision Detection</p>\n<p>使用 CSMA 协议进行数据发送</p>\n<p>发送过程中一直侦听信道 &lt;u&gt;(冲突检测)&lt;/u&gt;</p>\n<p>检测到冲突则立即停止发送，并等待一段随机时间，再侦听</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/Kj8XsLIzrTwmJih.png\" alt=\"image-20211211193703174\" /></p>\n<p>为了在发送时能检测到可能存在的冲突，CSMA.CD 要求所有数据帧都必须大于最小帧长 (2<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi></mrow><annotation encoding=\"application/x-tex\">\\tau</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.1132em;\">τ</span></span></span></span> * 数据传输速率)</p>\n<h6 id=\"csmaca\"><a class=\"anchor\" href=\"#csmaca\">#</a> CSMA/CA</h6>\n<p>IEEE802 无线局域网所用的多路访问协议，参考后续</p>\n<h4 id=\"533轮流访问不考\"><a class=\"anchor\" href=\"#533轮流访问不考\">#</a> 5.3.3 轮流访问 [不考]</h4>\n<p>节点轮流发送，但有更多信息要发送的节点能够占用更 长的时间</p>\n<h3 id=\"54局域网lan\"><a class=\"anchor\" href=\"#54局域网lan\">#</a> 5.4 局域网 (LAN)</h3>\n<h4 id=\"541局域网的基本概念与体系结构\"><a class=\"anchor\" href=\"#541局域网的基本概念与体系结构\">#</a> 5.4.1 局域网的基本概念与体系结构</h4>\n<p>集中在一个地理区域中的计算机网络</p>\n<p>属性</p>\n<ul>\n<li>范围限制</li>\n<li>传输技术</li>\n<li>拓扑结构</li>\n</ul>\n<h5 id=\"ieee802参考模型-只相当于链路层和物理层\"><a class=\"anchor\" href=\"#ieee802参考模型-只相当于链路层和物理层\">#</a> IEEE802 参考模型 - 只相当于链路层和物理层</h5>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/WNJSFu2D7a9b5Y3.png\" alt=\"image-20211211194132210\" /></p>\n<p>LLC 保证传输正确性</p>\n<p>MAC 解决共享信道访问</p>\n<h4 id=\"542链路层寻址与arp协议\"><a class=\"anchor\" href=\"#542链路层寻址与arp协议\">#</a> 5.4.2 链路层寻址与 ARP 协议</h4>\n<p>MAC 地址 / LAN 地址 / 物理地址</p>\n<ul>\n<li>将数据报从一个接口传送到物理上相互连接的另一个接口</li>\n<li>网络层及以上用 IP 地址，链路层及以下用硬件地址</li>\n</ul>\n<h5 id=\"arp地址解析协议\"><a class=\"anchor\" href=\"#arp地址解析协议\">#</a> ARP: 地址解析协议</h5>\n<p>每个主机上设有 ARP 高速缓存，里面有所在局域网上各主机和路由器的 IP 地址到硬件地址的 &lt;u&gt; 映射表 &lt;/u&gt;</p>\n<p>A 想向 B 发数据，先查看 ARP 中有无 B 的 IP, 如果有，就查出它的硬件地址，再将其发送</p>\n<p>没有，则运行 ARP 来找到 B 的硬件地址</p>\n<p>即主机 A 向所有主机广播请求，目的主机对主机 A 直接回应，同时将主机 A 的地址映射到自己的高速缓存中</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/OkLXE5xsCpnF7KN.png\" alt=\"image-20211211194645026\" /></p>\n<p>ARP 四种情况</p>\n<blockquote>\n<p>主机 -&gt; 本网络上另一个主机         ARP 找到目的硬件地址</p>\n<p>主机 -&gt; 另一个网络上的主机        ARP 找到本网络一个路由器地址</p>\n<p>路由器 -&gt; 本网络主机\t\t\t\t\tARP 找到目的主机的硬件地址</p>\n<p>路由器 -&gt; 另一个网络主机            ARP 找到本网络上另一个路由器硬件地址</p>\n</blockquote>\n<h4 id=\"543以太网与ieee8023\"><a class=\"anchor\" href=\"#543以太网与ieee8023\">#</a> 5.4.3 以太网与 IEEE802.3</h4>\n<p>星型拓扑结构</p>\n<ul>\n<li>\n<p>中心是交换机</p>\n</li>\n<li>\n<p>节点间不冲突</p>\n</li>\n</ul>\n<h5 id=\"以太网帧结构\"><a class=\"anchor\" href=\"#以太网帧结构\">#</a> 以太网帧结构</h5>\n<p><img data-src=\"https://s2.loli.net/2021/12/11/7JqZxaLi4CO51MA.png\" alt=\"image-20211211200110878\" /></p>\n<p>目的地址:</p>\n<blockquote>\n<p>第一位 0: 单节点接收</p>\n<p>1: 被一组节点接收</p>\n<p>全 1: 广播</p>\n</blockquote>\n<p>校验字段</p>\n<p>32 位 CRC 校验 (范围：目的地址，源地址，类型，数据)</p>\n<p>数据字段：最小长度为 46B, 小于 46 则填充，但这些填充不计入长度字段值中<br />\n最大长度为 1500B</p>\n<p>因此 Ethernet 帧最小长度 64B, 最大 1518B</p>\n<h5 id=\"以太网特点\"><a class=\"anchor\" href=\"#以太网特点\">#</a> 以太网特点</h5>\n<p>不可信 (接收方不发送 ACK 之类的)</p>\n<p>无连接 (无握手)</p>\n<p>MAC 控制:</p>\n<h5 id=\"以太网的csmacd\"><a class=\"anchor\" href=\"#以太网的csmacd\">#</a> 以太网的 CSMA/CD</h5>\n<p>将之前的强化冲突方式，设置为使用 &lt;u&gt; 二进制指数退避 &lt;/u&gt;</p>\n<ul>\n<li>在第 m 号冲突后 NIC 选择<ruby> 0,1,2,...$2<rp>(</rp><rt>{m-1</rt><rp>)</rp></ruby>$ 中的随机一个数 K</li>\n<li>然后等待 K*512 bit 时间</li>\n</ul>\n<h4 id=\"544无线局域网与ieee80211不考\"><a class=\"anchor\" href=\"#544无线局域网与ieee80211不考\">#</a> 5.4.4 无线局域网与 IEEE802.11 [不考]</h4>\n<p>无线网的介质访问控制</p>\n<p>特点：无法获得冲突信息</p>\n<p>目的：避免冲突</p>\n<p>方式</p>\n<blockquote>\n<p>物理层执行信道载波侦听</p>\n<p>信道空闲 -- 源节点等待 DIFS 后，仍然空闲，则发送一帧，然后等待 ACK 帧</p>\n<p>目的节点在收到正确的数据帧的 SIFS 时间后，向源节点发送 ACK 帧</p>\n</blockquote>\n<h6 id=\"csmaca-2\"><a class=\"anchor\" href=\"#csmaca-2\">#</a> CSMA/CA</h6>\n<p>允许发送端预订信道</p>\n<ul>\n<li>发送端发送请求帧到 AP</li>\n<li>AP 广播允许发送 (CTS) 的回复</li>\n<li>所有结点收到 CTS, 发送端发送</li>\n</ul>\n<h3 id=\"55数据链路层设备\"><a class=\"anchor\" href=\"#55数据链路层设备\">#</a> 5.5 数据链路层设备</h3>\n<h5 id=\"局域网交换机\"><a class=\"anchor\" href=\"#局域网交换机\">#</a> 局域网交换机</h5>\n<p>存储并转发以太网帧</p>\n<p>特征：对主机透明 (即 ip 地址什么的和它无关)</p>\n<p>自学习 -</p>\n<blockquote>\n<p>收到对应接口分组后记录对应接口 MAC 地址在自己对应接口上</p>\n<p>如果发现目的接口没有，会洪泛 (将分组分发到所有接口上，等待回复)</p>\n</blockquote>\n<h6 id=\"冲突域vs广播域\"><a class=\"anchor\" href=\"#冲突域vs广播域\">#</a> 冲突域 VS 广播域</h6>\n<p>冲突域；网络的一部分，在其中会发生帧冲突 (当两个设备同时发送数据报)</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/PYFwpzouJ9VhBre.png\" alt=\"image-20211209105458295\" /></p>\n<p>广播域：包含了通过链路层广播能直接相互了解的所有设备</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/l7OfskCEuRYMqb6.png\" alt=\"image-20211209105941059\" /></p>\n<h5 id=\"虚拟局域网-为了防止过多的广播信息引起不便\"><a class=\"anchor\" href=\"#虚拟局域网-为了防止过多的广播信息引起不便\">#</a> 虚拟局域网 -- 为了防止过多的广播信息引起不便</h5>\n<p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组</p>\n<p>每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。(在以太网帧中插入一个 4 字节的标识符，称为 VLAN 标记)</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/ier7sUByQbkouxL.png\" alt=\"image-20211209110309425\" /></p>\n<h2 id=\"6-物理层\"><a class=\"anchor\" href=\"#6-物理层\">#</a> 6. 物理层</h2>\n<h3 id=\"61通信基础\"><a class=\"anchor\" href=\"#61通信基础\">#</a> 6.1 通信基础</h3>\n<h4 id=\"611数据通信系统的基本概念\"><a class=\"anchor\" href=\"#611数据通信系统的基本概念\">#</a> 6.1.1 数据通信系统的基本概念</h4>\n<p>物理层目标：在通信信道上传输原始比特</p>\n<p>确定与传输介质的接口的一些特性</p>\n<ul>\n<li>机械特性</li>\n<li>电气特性</li>\n<li>功能特性</li>\n<li>过程特性</li>\n</ul>\n<h4 id=\"612编码与调制\"><a class=\"anchor\" href=\"#612编码与调制\">#</a> 6.1.2 编码与调制</h4>\n<h4 id=\"613奈奎斯特定理和香农定理\"><a class=\"anchor\" href=\"#613奈奎斯特定理和香农定理\">#</a> 6.1.3 奈奎斯特定理和香农定理</h4>\n<h3 id=\"62物理层设备\"><a class=\"anchor\" href=\"#62物理层设备\">#</a> 6.2 物理层设备</h3>\n<h3 id=\"集线器\"><a class=\"anchor\" href=\"#集线器\">#</a> 集线器</h3>\n<h2 id=\"7-综合\"><a class=\"anchor\" href=\"#7-综合\">#</a> 7. 综合</h2>\n<h3 id=\"71各层设备的广播域-冲突域及总结\"><a class=\"anchor\" href=\"#71各层设备的广播域-冲突域及总结\">#</a> 7.1 各层设备的广播域、冲突域及总结</h3>\n<h3 id=\"72web访问全过程\"><a class=\"anchor\" href=\"#72web访问全过程\">#</a> 7.2Web 访问全过程</h3>\n",
            "tags": [
                "大三",
                "计算机网络",
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2021/12/09/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/",
            "url": "http://example.com/2021/12/09/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/",
            "title": "网络地址转换",
            "date_published": "2021-12-09T02:48:35.000Z",
            "content_html": "<h3 id=\"网络地址转换\"><a class=\"anchor\" href=\"#网络地址转换\">#</a> 网络地址转换</h3>\n<p>目的：解决 ip 稀缺</p>\n<p>三个专用地址块</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/15aVHB4QMLxdjTC.png\" alt=\"image-20211118100015197\" /></p>\n<p>原理：本地网络中的所有计算机在访问 Internet 时使用同一个 IP 地址<br />\n，within the local network, computers use private addresses for<br />\nrouting intramural traffic 在本地网络中，计算机使用专用地址<br />\n进行路由。对于目的地址是专用地址的数据报，路由器一律<br />\n不予转发。</p>\n<p>本质：通过端口号区分主机</p>\n<h3 id=\"ipv6\"><a class=\"anchor\" href=\"#ipv6\">#</a> IPV6</h3>\n<p>同样是为了改变缺少 ip 地址的问题</p>\n<p>源 ip:128 位</p>\n<p>目的 ip:128 位</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/CaiYJWqQs4EG1UB.png\" alt=\"image-20211118111114068\" /></p>\n<h3 id=\"隧道技术\"><a class=\"anchor\" href=\"#隧道技术\">#</a> 隧道技术</h3>\n<p>解决 ipv4 和 ipv6 共存</p>\n<p>ipv6 作为 ipv4 的 payload (数据) 发送</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/PxaInA3sEKMHGpF.png\" alt=\"image-20211118111549533\" /></p>\n",
            "tags": [
                "大三",
                "计算机网络",
                "网络地址"
            ]
        },
        {
            "id": "http://example.com/2021/12/09/%E7%BD%91%E7%BB%9C%E5%B1%82/",
            "url": "http://example.com/2021/12/09/%E7%BD%91%E7%BB%9C%E5%B1%82/",
            "title": "网络层",
            "date_published": "2021-12-09T02:48:15.000Z",
            "content_html": "<h1 id=\"网络层-控制平面\"><a class=\"anchor\" href=\"#网络层-控制平面\">#</a> 网络层 - 控制平面</h1>\n<h2 id=\"路由算法\"><a class=\"anchor\" href=\"#路由算法\">#</a> 路由算法</h2>\n<h6 id=\"产生路由表的算法\"><a class=\"anchor\" href=\"#产生路由表的算法\">#</a> 产生路由表的算法</h6>\n<h3 id=\"图论抽象\"><a class=\"anchor\" href=\"#图论抽象\">#</a> 图论抽象</h3>\n<p>Graph: G = <strong>(N,E)</strong></p>\n<p><strong>N</strong> = set of routers = {u, v, w, x, y, z} 节点是<strong>路由器</strong></p>\n<p><strong>E</strong> = set of links ={(u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) }  边是<strong>物理链路</strong></p>\n<p>链路开销 Cost of link：时延、费用或拥塞等级 路径开销 Cost of path：c (x1 , x2 , x3 ,…, xp) = c (x1 ,x2 ) + c (x2 ,x3 ) + … +  c (xp-1 ,xp )</p>\n<p><strong>路由算法</strong>：找到开销最小的路径 (路由器序列)</p>\n<p><strong>分散式</strong>算法 -- 只知道和部分路径，通过和邻居交换信息</p>\n<p>典型就是下面这个算法</p>\n<h3 id=\"距离向量路由算法\"><a class=\"anchor\" href=\"#距离向量路由算法\">#</a> 距离向量路由算法</h3>\n<h4 id=\"描述\"><a class=\"anchor\" href=\"#描述\">#</a> 描述</h4>\n<ol>\n<li>\n<p>节点 x 维护距离向量</p>\n<p>Dx=[dx (y): yєN ]<br />\n(如果 y 不是 x 的邻居节点，则 dx (y)=∞, 否则 dx (y)= c (x,y))</p>\n</li>\n<li>\n<p>每个节点周期性向其邻居节点发送它自己的 距离向量，节点 x 保存其邻居节点的距离向量<br />\n Dv = [dv (y): y є N ]</p>\n</li>\n<li>\n<p>n 当节点 x 接收到来自邻居的 新距离向量，它使用 B-F 方程更新自己的 DV :<br />\nDx (y) ← minv {c(x,v) + Dv (y)} for each node y ∊ N<br />\nBellman-Ford 方程：</p>\n<ol>\n<li>定义<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>d</mi><mi>x</mi></msub></mrow><annotation encoding=\"application/x-tex\">d_x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84444em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> (y) = 从 x 到 y 的最小开销路径的开销，<br />\nc (x,v) = 从 x 到邻居节点 v 的链路的开销</li>\n<li c(x,v)=\"\" +=\"\" dv=\"\" (y)=\"\">则 dx (y) = minv</li>\n<li>取值最小的节点对应最短路径中的<strong>下一跳</strong> (只有一个地址)➜ 转发表</li>\n</ol>\n</li>\n</ol>\n<p>​\t示例<br />\n &lt; img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzA5L0hoSUNHVWFrcWZ0MnptMS5wbmc=\">https://s2.loli.net/2021/12/09/HhICGUakqft2zm1.png</span>&quot; alt=&quot;image-20211122134953146&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<h3 id=\"链路状态路由算法\"><a class=\"anchor\" href=\"#链路状态路由算法\">#</a> 链路状态路由算法・</h3>\n<ol>\n<li>\n<p>Discover its neighbors, learn their network address. <strong>发现邻居，学习它们的网络地址</strong></p>\n</li>\n<li>\n<p>Measure the delay or cost to each of its neighbors. <strong>测量到每一个邻居的时延或开销</strong></p>\n</li>\n<li>\n<p>Construct a packet (link state packet)telling all it has  just learned. <strong>构造一个分组 (链路状态分组) 来通 告其学习到的所有信息</strong></p>\n</li>\n<li>\n<p>Send this packet to all other routers.  <strong>向所有路由器发送该分组</strong></p>\n</li>\n<li>\n<p>Compute the shortest path to every other router.  <strong>计算到其他路由器的最短路径</strong><br />\n使用 Dijkstra 算法计算最短路径<br />\n &lt; img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzA5L21DZEY0RzJ3Tzd2eHBVVy5wbmc=\">https://s2.loli.net/2021/12/09/mCdF4G2wO7vxpUW.png</span>&quot; alt=&quot;image-20211122143134224&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n</li>\n</ol>\n<h2 id=\"路由协议\"><a class=\"anchor\" href=\"#路由协议\">#</a> 路由协议</h2>\n<p>受到分组压力，单位需求的影响，产生了 as (自治系统)</p>\n<p>系统内可以用之前的算法，系统外 --? 自治系统间专门的路由协议</p>\n<h3 id=\"openshortestpathfirst路由协议\"><a class=\"anchor\" href=\"#openshortestpathfirst路由协议\">#</a> O (pen) S (hortest) P (ath) F (irst) 路由协议</h3>\n<h5 id=\"自治系统内路由-开放最短路径优先\"><a class=\"anchor\" href=\"#自治系统内路由-开放最短路径优先\">#</a> 自治系统内路由 - 开放最短路径优先</h5>\n<h6 id=\"使用的算法是链路状态算法\"><a class=\"anchor\" href=\"#使用的算法是链路状态算法\">#</a> 使用的算法是<strong>链路状态算法</strong></h6>\n<p>OSPF 的特点</p>\n<ol>\n<li>安全性 -- 报文经过签名鉴别</li>\n<li>使用多条开销相同的路径</li>\n<li>对每条链路，为不同的服务类型设置多种开销度量</li>\n<li>集成的单播和多播支持</li>\n</ol>\n<h5 id=\"层次ospf\"><a class=\"anchor\" href=\"#层次ospf\">#</a> 层次 ospf</h5>\n<p>自治系统内进一步再分</p>\n<h3 id=\"bgp路由协议border-gateway-protocol\"><a class=\"anchor\" href=\"#bgp路由协议border-gateway-protocol\">#</a> BGP 路由协议 (border gateway protocol)</h3>\n<h5 id=\"-自治系统间路由\"><a class=\"anchor\" href=\"#-自治系统间路由\">#</a> - 自治系统间路由</h5>\n<p>算法 - 距离向量算法 (改名 --- 路径向量算法)</p>\n<ol>\n<li>eBGP: Obtain subnet reachability information from</li>\n</ol>\n<p>neighboring ASes. 从相邻 AS 获得子网可达性信息</p>\n<ol start=\"2\">\n<li>iBGP: Propagate reachability information to all AS-internal</li>\n</ol>\n<p>routers. 向 AS 内部的所有路由器传播可达性信息</p>\n<ol start=\"3\">\n<li>Determine “good” routes to subnets based on reachability</li>\n</ol>\n<p>information and policy. 根据可达性信息和策略，决定到子网</p>\n<p>的 “好” 路由</p>\n<h2 id=\"icmp-the-internet-control\"><a class=\"anchor\" href=\"#icmp-the-internet-control\">#</a> •ICMP-The Internet Control</h2>\n<p>差错报告 -- 不可达网络 \\ 主机 \\ 端口 \\ 协议</p>\n<p>回声请求</p>\n<p>trace route</p>\n<p>源主机从 ttl=1, 一点点开始发送更大的 ttl, 目的端口号设置为一个不可能到达的端口，</p>\n<p>当 ttl 超时时，该路由器发送一个 ICMP 报文到源主机，这样会获取路径上路由器的信息</p>\n<p>到达目的主机后，会返回一个端口不可达报文，探测结束</p>\n<h2 id=\"message-protocol\"><a class=\"anchor\" href=\"#message-protocol\">#</a> Message Protocol</h2>\n<h2 id=\"网络管理snmp协议\"><a class=\"anchor\" href=\"#网络管理snmp协议\">#</a> 网络管理 ——SNMP 协议</h2>\n",
            "tags": [
                "大三",
                "计算机网络",
                "网络层"
            ]
        },
        {
            "id": "http://example.com/2021/12/09/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/",
            "url": "http://example.com/2021/12/09/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/",
            "title": "数据链路层",
            "date_published": "2021-12-09T02:48:01.000Z",
            "content_html": "<h1 id=\"12_2_数据链路层\"><a class=\"anchor\" href=\"#12_2_数据链路层\">#</a> 12_2_数据链路层</h1>\n<h2 id=\"1-数据链路层的基本功能\"><a class=\"anchor\" href=\"#1-数据链路层的基本功能\">#</a> 1. 数据链路层的基本功能</h2>\n<p><strong>&lt;u&gt; 将数据报从一个节点经过一条链路传输到相邻节点 &lt;/u&gt;</strong></p>\n<ol>\n<li>\n<p>组帧：将数据报封装进帧，加上首部和尾部</p>\n</li>\n<li>\n<p>链路接入：如果共享媒体，控制信道接入，使用帧首部中的 “MAC” 地址标识源和目的地</p>\n</li>\n<li>\n<p>相邻节点间的可靠交付，</p>\n</li>\n<li>\n<p>检错</p>\n</li>\n<li>\n<p>纠错：接收方识别并纠正比特差错，而不需要重传</p>\n</li>\n</ol>\n<p>它放在哪？适配器 (网卡), 和主机系统总线相连</p>\n<h2 id=\"2差错控制\"><a class=\"anchor\" href=\"#2差错控制\">#</a> 2. 差错控制</h2>\n<p><strong>通过通信信道接收的数据与发送的数据不一致的现象称为传输差错 (简称差错)。</strong></p>\n<h3 id=\"21检错编码\"><a class=\"anchor\" href=\"#21检错编码\">#</a> 2.1 检错编码</h3>\n<h4 id=\"211单比特奇偶校验\"><a class=\"anchor\" href=\"#211单比特奇偶校验\">#</a> 2.1.1 单比特奇偶校验</h4>\n<p>奇偶校验码是一种通过增加冗余位使得码字中 “1” 的个数恒为奇数或偶数的编码方法</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/JEV1Ht24Sz6iWuk.png\" alt=\"image-20211202102617007\" /></p>\n<p>能力：能够检测单 (奇数) 个比特差错</p>\n<h4 id=\"212internetchecksum-udp里讲过\"><a class=\"anchor\" href=\"#212internetchecksum-udp里讲过\">#</a> 2.1.2InternetChecksum--UDP 里讲过</h4>\n<h4 id=\"213循环冗余校验\"><a class=\"anchor\" href=\"#213循环冗余校验\">#</a> 2.1.3 循环冗余校验</h4>\n<p>原始数据：D</p>\n<p>校验位：长度 r,</p>\n<p>原始数据后补上 r 位 0,</p>\n<p>Generator: G:r+1 的长度</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/ofx3QTMktbhvgzR.png\" alt=\"image-20211202103409058\" /></p>\n<p>D 不断异或 G (其实是求余数), 最后剩下的为校验位</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzA5L0VzSUgxOVlLaGJTWFpxNy5wbmc=\">https://s2.loli.net/2021/12/09/EsIH19YKhbSXZq7.png</span>&quot; alt=&quot;image-20211202103258900&quot; style=&quot;zoom:33%;&quot; /&gt;</p>\n<p>检测能力</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/QD8Eu6FTqJRkfwx.png\" alt=\"image-20211202103444659\" /></p>\n<h4 id=\"214二维奇偶校验\"><a class=\"anchor\" href=\"#214二维奇偶校验\">#</a> 2.1.4 二维奇偶校验</h4>\n<p>二维奇偶校验能够检测并纠正单比特差错</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/dsNAQDYEWB54bO6.png\" alt=\"image-20211202103521291\" /></p>\n<h3 id=\"22纠错编码\"><a class=\"anchor\" href=\"#22纠错编码\">#</a> 2.2 纠错编码</h3>\n<h2 id=\"3介质访问控制\"><a class=\"anchor\" href=\"#3介质访问控制\">#</a> 3. 介质访问控制</h2>\n<p>点对点 / 广播</p>\n<h3 id=\"31信道划分\"><a class=\"anchor\" href=\"#31信道划分\">#</a> 3.1 信道划分</h3>\n<p>将信道划分为较小的 “片” (时隙，频率，编码)</p>\n<p>为节点分配专用的片</p>\n<h4 id=\"311频分多路复用\"><a class=\"anchor\" href=\"#311频分多路复用\">#</a> 3.1.1 频分多路复用</h4>\n<h4 id=\"322时分多路复用\"><a class=\"anchor\" href=\"#322时分多路复用\">#</a> 3.2.2 时分多路复用、</h4>\n<h4 id=\"313波分多路复用\"><a class=\"anchor\" href=\"#313波分多路复用\">#</a> 3.1.3 波分多路复用</h4>\n<h4 id=\"314码分多路访问\"><a class=\"anchor\" href=\"#314码分多路访问\">#</a> 3.1.4 码分多路访问</h4>\n<h3 id=\"32随机访问\"><a class=\"anchor\" href=\"#32随机访问\">#</a> 3.2 随机访问</h3>\n<p>不划分信道，允许冲突</p>\n<p>从 “冲突” 中恢复</p>\n<h4 id=\"321aloha协议-csma协议\"><a class=\"anchor\" href=\"#321aloha协议-csma协议\">#</a> 3.2.1ALOHA 协议、CSMA 协议、</h4>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211202111307619.png\" alt=\"image-20211202111307619\" /></p>\n<p>传播时延的冲突:</p>\n<p>传播时延：传输距离 / 光速</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/oRzjkmdAZTFytSf.png\" alt=\"image-20211202111802943\" /></p>\n<p>端到端往返时延 2t 称为争用期，或冲突窗口</p>\n<h4 id=\"322csmacd协议\"><a class=\"anchor\" href=\"#322csmacd协议\">#</a> 3.2.2CSMA/CD 协议</h4>\n<p>需要在发送完帧之前就能收到自己发送出去的数据，即帧的传输时延至少是数据在总线中的传播时延的 2 倍</p>\n<p><em><em>最小帧长 = 传播时延</em> 2 <em>数据传输速率</em></em></p>\n<p>例如，以太网的冲突窗口长度为 51.2µs，数据传输速</p>\n<p>率为 10Mbps，51.2µs 可以发送 512bit（64B）数据，因</p>\n<p>此，64B 是以太网的最短帧长度；</p>\n<h4 id=\"csmaca协议\"><a class=\"anchor\" href=\"#csmaca协议\">#</a> 、CSMA/CA 协议</h4>\n<h3 id=\"33轮流协议\"><a class=\"anchor\" href=\"#33轮流协议\">#</a> 3.3 轮流协议</h3>\n<h4 id=\"331令牌传递协议\"><a class=\"anchor\" href=\"#331令牌传递协议\">#</a> 3.3.1 令牌传递协议</h4>\n<h4 id=\"332轮询协议\"><a class=\"anchor\" href=\"#332轮询协议\">#</a> 3.3.2 轮询协议</h4>\n<h2 id=\"4局域网\"><a class=\"anchor\" href=\"#4局域网\">#</a> 4. 局域网</h2>\n<h3 id=\"41局域网的基本概念与体系结构\"><a class=\"anchor\" href=\"#41局域网的基本概念与体系结构\">#</a> 4.1 局域网的基本概念与体系结构</h3>\n<h3 id=\"42局域网寻址与arp协议\"><a class=\"anchor\" href=\"#42局域网寻址与arp协议\">#</a> 4.2 局域网寻址与 ARP 协议</h3>\n<h3 id=\"43以太网与ieee-8023\"><a class=\"anchor\" href=\"#43以太网与ieee-8023\">#</a> 4.3 以太网与 IEEE 802.3</h3>\n<h5 id=\"431以太网拓扑结构\"><a class=\"anchor\" href=\"#431以太网拓扑结构\">#</a> 4.3.1 以太网拓扑结构</h5>\n<p>90 年代前：总线型拓扑 (单冲突域)</p>\n<p>现在星形 (中心是交换机，节点之间不冲突，不需要 CSMA)</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/MDJZpHrGhb3BewT.png\" alt=\"image-20211209100351905\" /></p>\n<p>4.3.2 以太网帧结构</p>\n<p>...</p>\n<p>4.3.3 以太网属性</p>\n<p>•connectionless: no handshaking between sending and receiving NICs</p>\n<p>连接之间没有握手</p>\n<p>•unreliable: receiving NIC doesn't send ACKs or NAKs to sending NIC</p>\n<p>就是说，如果没收到就直接扔了，不发消息</p>\n<p>以太网的 MAC Control</p>\n<p>CMSA/CD + 指数回避 (用来防止连续冲突)</p>\n<h3 id=\"44无线局域网ieee-80211\"><a class=\"anchor\" href=\"#44无线局域网ieee-80211\">#</a> 4.4 无线局域网 (IEEE 802.11)</h3>\n<p>4.4.1 典型结构</p>\n<p>&lt;img src=&quot;<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zMi5sb2xpLm5ldC8yMDIxLzEyLzA5LzZTRTkxbU1OQlZwcmdBaC5wbmc=\">https://s2.loli.net/2021/12/09/6SE91mMNBVprgAh.png</span>&quot; alt=&quot;image-20211209102241124&quot; style=&quot;zoom:33%;&quot; /&gt;</p>\n<p>4.4.2 冲突控制</p>\n<p>CSMA/C(ollision)A(voidance)</p>\n<p>允许发送端预订信道</p>\n<ul>\n<li>发送端发送请求帧到 AP</li>\n<li>AP 广播允许发送 (CTS) 的回复</li>\n<li>所有结点收到 CTS, 发送端发送</li>\n</ul>\n<h2 id=\"5数据链路层设备\"><a class=\"anchor\" href=\"#5数据链路层设备\">#</a> 5. 数据链路层设备</h2>\n<h3 id=\"51局域网交换机\"><a class=\"anchor\" href=\"#51局域网交换机\">#</a> 5.1 局域网交换机</h3>\n<p>查看进入的 MAC 地址，然后转发给出链路</p>\n<p>**&lt;u&gt; 透明 &lt;/u&gt;<strong> 因此在转发的时候分组里</strong> &lt;u&gt; 不会 &lt;/u&gt;** 有交换机的物理地址</p>\n<p>&lt;u&gt;<strong> 自学习</strong> &lt;/u&gt;:</p>\n<p>收到对应接口分组后记录对应接口 MAC 地址在自己对应接口上</p>\n<p>如果发现目的接口没有，会洪泛 (将分组分发到所有接口上，等待回复)</p>\n<p>5.2 冲突域 vs 广播域</p>\n<p>冲突域</p>\n<p>当两个设备在同时发送分组的时候会冲突</p>\n<p>下面每个圈都是冲突域</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/PYFwpzouJ9VhBre.png\" alt=\"image-20211209105458295\" /></p>\n<p>广播</p>\n<p>通过广播能发到的一堆设备</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/l7OfskCEuRYMqb6.png\" alt=\"image-20211209105941059\" /></p>\n<p>虚拟局域网 (为了防止过多的广播信息引起不便)</p>\n<p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组</p>\n<p>每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。(在以太网帧中插入一个 4 字节的标识符，称为 VLAN 标记)</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/09/ier7sUByQbkouxL.png\" alt=\"image-20211209110309425\" /></p>\n",
            "tags": [
                "大三",
                "计算机网络",
                "计网"
            ]
        },
        {
            "id": "http://example.com/2021/12/07/%E5%A4%8D%E4%B9%A0/",
            "url": "http://example.com/2021/12/07/%E5%A4%8D%E4%B9%A0/",
            "title": "21/12/6 软件体系结构复习",
            "date_published": "2021-12-07T14:09:47.000Z",
            "content_html": "<h1 id=\"复习\"><a class=\"anchor\" href=\"#复习\">#</a> 复习</h1>\n<h2 id=\"1基本概念\"><a class=\"anchor\" href=\"#1基本概念\">#</a> 1. 基本概念</h2>\n<h3 id=\"软件体系结构\"><a class=\"anchor\" href=\"#软件体系结构\">#</a> 软件体系结构</h3>\n<p>系统的基本组织结构，包括系统构成要素，这些构成要素之间以及与环境之间的关系，系统设计及演化时所应遵循的原则</p>\n<h3 id=\"什么设计模式\"><a class=\"anchor\" href=\"#什么设计模式\">#</a> 什么设计模式？</h3>\n<h6 id=\"是一套被反复使用多数人知晓的经过分类编目的代码设计经验的总结\"><a class=\"anchor\" href=\"#是一套被反复使用多数人知晓的经过分类编目的代码设计经验的总结\">#</a> 是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结.</h6>\n<h3 id=\"为什么要用设计模式\"><a class=\"anchor\" href=\"#为什么要用设计模式\">#</a> 为什么要用设计模式？</h3>\n<p>为了 &lt;u&gt; 可重用代码 &lt;/u&gt;, 让代码更容易 &lt; u &gt; 被他人理解 &lt;/u&gt;, 保证 &lt; u &gt; 代码可靠性 &lt;/u&gt;</p>\n<h3 id=\"非功能需求有哪些含义是什么\"><a class=\"anchor\" href=\"#非功能需求有哪些含义是什么\">#</a> 非功能需求有哪些？，含义是什么？</h3>\n<ol>\n<li>\n<p>性能</p>\n</li>\n<li>\n<p>可扩展性 / 伸缩性</p>\n</li>\n<li>\n<p>可维护性</p>\n</li>\n<li>\n<p>可用性</p>\n</li>\n<li>\n<p>安全性</p>\n</li>\n<li>\n<p>业务质量<br />\n成本，周期，投入的人力，需要的资源</p>\n</li>\n<li>\n<p>性能需求：用户在软件响应速度，结果精度，运行时资源消耗量等方面的要求</p>\n</li>\n<li>\n<p>可靠性需求：用户在软件失效的频率，严重程度，易恢复性，以及故障可预测性等方面的要求</p>\n</li>\n<li>\n<p>易用性要求：用户要求在界面的易用性，美观性，以及对面向用户的文档和培训资料等方面的要求</p>\n</li>\n<li>\n<p>安全性需求：用户在身份认证，授权控制，私密性等方面的要求</p>\n</li>\n<li>\n<p>运行环境约束：用户对软件系统运行环境的要求</p>\n</li>\n<li>\n<p>外部接口：用户对待开发的软件系统与其他软件系统或硬件设备之间的接口的要求</p>\n</li>\n<li>\n<p>可保障性要求：用户在软件可配置性，可扩展性，可维护性，可移植性方面的要求</p>\n</li>\n</ol>\n<h3 id=\"编程的三个层次\"><a class=\"anchor\" href=\"#编程的三个层次\">#</a> 编程的三个层次？</h3>\n<p>针对实现编程</p>\n<p>Dog d = new Dog();</p>\n<p>d.bark();</p>\n<p>针对接口 / 超类型编程</p>\n<p>Animal animal = new Dog();</p>\n<p>animal.makeSound();</p>\n<p>运行时才指定具体实现的对象</p>\n<p>a=getAnimal();</p>\n<p>a.makeSound();</p>\n<h3 id=\"设计模式的三大原则\"><a class=\"anchor\" href=\"#设计模式的三大原则\">#</a> 设计模式的三大原则</h3>\n<h6 id=\"单一职责\"><a class=\"anchor\" href=\"#单一职责\">#</a> 单一职责</h6>\n<p>一个类只负责一个功能领域中相应的职责，</p>\n<h6 id=\"依赖倒置\"><a class=\"anchor\" href=\"#依赖倒置\">#</a> 依赖倒置</h6>\n<p>针对接口编程，而非针对实现编程</p>\n<p>即程序中所有的依赖关系都是终止与抽象类或者直接接口.</p>\n<h6 id=\"开闭原则\"><a class=\"anchor\" href=\"#开闭原则\">#</a> 开闭原则</h6>\n<p>对拓展开放，对修改关闭</p>\n<h6 id=\"面向对象的三大原则\"><a class=\"anchor\" href=\"#面向对象的三大原则\">#</a> 面向对象的三大原则</h6>\n<h2 id=\"软件体系结构-2\"><a class=\"anchor\" href=\"#软件体系结构-2\">#</a> 软件体系结构</h2>\n<h3 id=\"分层风格\"><a class=\"anchor\" href=\"#分层风格\">#</a> 分层风格</h3>\n<p>指将软件设计成层次结构，每个层为其上层服务，同时又是其下层的客户，不允许隔层调用</p>\n<p>优点</p>\n<ol>\n<li>层次结构 支持基于随着层次不断增加而不断抽象的设计。能将一个复杂的问题分一系列从初等的与硬件相关的功能到可以被用户使用的高级功能.</li>\n<li>支持更新。每层只和两个层交互，因此，在接口不变的前提下，可以单独修改或更换某一层的某些组件而不影响其他层.</li>\n<li>支持复用.</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>不是什么系统都容易被组织成层次结构</li>\n<li>有时层次结构的逻辑上的较高层级和较低层级会有比较紧密的耦合</li>\n<li>正确的层次抽象往往可能很困难.</li>\n</ol>\n<h3 id=\"管道-过滤器风格\"><a class=\"anchor\" href=\"#管道-过滤器风格\">#</a> 管道 - 过滤器风格</h3>\n<p>每个过滤器都有一组输入和输出，组件读入输入数据流，经过数据处理，然后产生输出数据流.</p>\n<p>系统由负责运送数据的管道和负责对数据进行处理的过滤器组成</p>\n<p>优点</p>\n<ol>\n<li>高内聚低耦合</li>\n<li>允许设计者将整个系统的输入 / 输出行为看做是多个过滤器行为的简单合成</li>\n<li>支持软件重用</li>\n<li>系统维护和增强系统性能简单</li>\n<li>允许对一些如吞吐量，死锁等属性的分析</li>\n<li>支持并发</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>导致进程称为批处理结构</li>\n<li>不适合处理交互应用</li>\n<li>因为每个过滤器上都增加了解析和合成数据的工作，因此系统性能下滑，</li>\n</ol>\n<h3 id=\"主程序-子程序风格\"><a class=\"anchor\" href=\"#主程序-子程序风格\">#</a> 主程序 - 子程序风格</h3>\n<p>采取分而治之策略，将一个复杂的问题分解为多个独立的字问题</p>\n<h5 id=\"自顶向下功能化设计思想结构化设计\"><a class=\"anchor\" href=\"#自顶向下功能化设计思想结构化设计\">#</a> 自顶向下功能化设计思想 (结构化设计)</h5>\n<p>从功能需求出发，将一个整体问题分解为多个子问题，然后将子问题划分为几个更小的子问题，直到不可划分为止</p>\n<h6 id=\"优点\"><a class=\"anchor\" href=\"#优点\">#</a> 优点</h6>\n<ol>\n<li>逻辑设计与物理设计分开</li>\n<li>开发过程中形成一套规范化的文档，以便后期修改和维护</li>\n</ol>\n<p>适用于组织相对稳定，业务处理过程规范，需求明确且在一定时期内不会发生大的变化的大型复杂系统的开发.</p>\n<p>缺点：开发周期长，系统难以适应环境的变化及开发过程复杂繁琐</p>\n<p>功能演化困难，显示中的系统功能不容易描述，功能化设计丢掉了数据与数据结构，产生的可复用代码少.</p>\n<h3 id=\"面向对象软件体系结构\"><a class=\"anchor\" href=\"#面向对象软件体系结构\">#</a> 面向对象软件体系结构</h3>\n<p>系统看做由一些对象的集合构成，消息从一个对象发送到另外一个对象。每个对象都有其相关的功能</p>\n<p>对象是一个具有状态和行为的实体。一个对象存储它的状态在域中，面向对象设计隐藏对象的内部状态，并且要求所有对象之间的交互都通过该对象的方法，这叫做数据封装，是面向对象编程的基本原则.</p>\n<p>面向对象设计的特点</p>\n<ol>\n<li>封装性，限制对特定信息的访问</li>\n<li>继承性，共享同一个功能定义</li>\n<li>动态绑定性：在程序运行前，不知道创建哪个类的对象，运行时才动态生成</li>\n<li>复用和可维护性：因为封装与局部化</li>\n<li>系统功能通过对象服务表示：对象的接口提供了一系列的方法.</li>\n<li>共享数据区域被取消</li>\n<li>对象可以是分布的。通过函数或者方法调用互相交互.</li>\n<li>对象是对现实世界的抽象并且可以自己管理自己.</li>\n</ol>\n<p>优缺点</p>\n<p>优点:</p>\n<ol>\n<li>容易维护</li>\n<li>可复用性好</li>\n<li>映射现实世界</li>\n<li>容易对一个系统进行剖分</li>\n</ol>\n<p>缺点</p>\n<ol>\n<li>占用欧冠内存较大。因为每个新被创建的对象都必须占用一块内存，而面向对象程序中，往往有大量对象被创建</li>\n<li>一个对象要和另外一个对象交互，该对象必须知道另外一个对象的身份，包括对象名，方法名和参数类型等.</li>\n</ol>\n<h3 id=\"基于共享数据的事件风格\"><a class=\"anchor\" href=\"#基于共享数据的事件风格\">#</a> 基于共享数据的事件风格</h3>\n<ol>\n<li>系统中的每个组件可以注册一种事件</li>\n<li>当一个组件要发布事件时，该组件可以广播一个或多个事件到事件空间</li>\n<li>每当一个事件被广播了，系统将负责自动调用那些已经注册了该事件的组件或者过程，被调用的组件将运行.</li>\n</ol>\n<h2 id=\"2设计模式\"><a class=\"anchor\" href=\"#2设计模式\">#</a> 2. 设计模式</h2>\n<h3 id=\"mvc模式\"><a class=\"anchor\" href=\"#mvc模式\">#</a> mvc 模式</h3>\n<p>model 包含核心数据和功能，独立于输入行为和输出表示</p>\n<p>View 将模型中的数据显示给用户</p>\n<p>Controller 处理用户输入，如果用户通过一个 view 的 controller 改变了 model, 其他 controller 必须反映出该改变，即当数据发生变化的时候，model 负责同志所有的 view, 告诉他们数据已经改变了.(观察者模式，model 对象是被观察者，controller 是观察者)</p>\n<h4 id=\"优缺点\"><a class=\"anchor\" href=\"#优缺点\">#</a> 优缺点</h4>\n<p>优点</p>\n<ol>\n<li>对于同一个模型，可以有不同的视图和控制器，一遍提供给用户不同类型的用户图形界面</li>\n<li>改变 - 传播机制保证了模型在改变的同时自动刷新所有的视图</li>\n<li>mvc 体系结构的设计使的改变图形界面非常容易，适合业务逻辑较少改变，而图形界面需要经常改变的应用</li>\n<li>全部的核心数据和核心功能都包含在模型中，很容易对核心的应用进行测试</li>\n<li>可拓展性比较好</li>\n</ol>\n<h3 id=\"命令模式\"><a class=\"anchor\" href=\"#命令模式\">#</a> 命令模式</h3>\n<p>三个部件</p>\n<p>客户程序</p>\n<p>调用者程序</p>\n<p>被调用者程序</p>\n<p>解除调用者类与被调用者类的耦合 -- 为响应客户新请求的行动创建一个抽象</p>\n<p>client 对象负责初始化 Command 对象，并且提供将来要调用的方法的全部信息</p>\n<p>Invoker 决定什么时候调用所要调用的方法</p>\n<p>receiver 是含有索要调用方法的代码的实例</p>\n<h3 id=\"3期末复习\"><a class=\"anchor\" href=\"#3期末复习\">#</a> 3. 期末复习</h3>\n",
            "tags": [
                "大三",
                "软件",
                "软件体系结构"
            ]
        },
        {
            "id": "http://example.com/2021/12/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
            "url": "http://example.com/2021/12/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
            "title": "21/12/6 软件体系结构复习-设计模式",
            "date_published": "2021-12-07T14:09:47.000Z",
            "content_html": "<h3 id=\"策略模式\"><a class=\"anchor\" href=\"#策略模式\">#</a> 策略模式</h3>\n<h6 id=\"基本原则责任分离高内聚低耦合\"><a class=\"anchor\" href=\"#基本原则责任分离高内聚低耦合\">#</a> 基本原则：责任分离 + 高内聚低耦合</h6>\n<h4 id=\"各部分组成及说明\"><a class=\"anchor\" href=\"#各部分组成及说明\">#</a> 各部分组成及说明</h4>\n<ol>\n<li>strategy: 定义了一个共同的接口，所有的具体算法类实现这个接口。换进该类 context 调用这个接口调用具体的算法类</li>\n<li>ConcreteStragety 封装了具体的算法，实现统一个几口</li>\n<li>Context 环境类。用于配置一个具体的算法策略对象，维持一个策略接口类型的参考，并且可以定义一个让接口 Strategy 的具体对象访问的接口 (可省略)</li>\n</ol>\n<h4 id=\"使用策略模式的情况\"><a class=\"anchor\" href=\"#使用策略模式的情况\">#</a> 使用策略模式的情况</h4>\n<ol>\n<li>当有多个行为上不同但是相关的类存在.</li>\n<li>当某个算法使用用户不该知道的数据时，使用策略模式可以将算法实现细节隐藏起来.</li>\n<li>当一个类有多种行为，这些行为以大块的条件语句实现时，可以将这些条件块移入他们自己的 Strategy 类中</li>\n</ol>\n<h5 id=\"使用策略模式的出发点\"><a class=\"anchor\" href=\"#使用策略模式的出发点\">#</a> 使用策略模式的出发点</h5>\n<ol>\n<li>将一组相关的算法封装为各个策略分支，从而将策略分支相关的代码隐藏起来</li>\n<li>提升程序的可拓展性</li>\n</ol>\n<h4 id=\"优点\"><a class=\"anchor\" href=\"#优点\">#</a> 优点</h4>\n<ol>\n<li>得到一系列可服用的算法，这些算法继承一个共同的抽象类，因此公有的功能可以放到超类中</li>\n<li>将不同算法封装在不同的策略子类中，使逻辑更加清晰，各个算法可以独立地变化</li>\n<li>是功能改变或拓展变得更容易</li>\n</ol>\n<h2 id=\"创建型模式\"><a class=\"anchor\" href=\"#创建型模式\">#</a> 创建型模式</h2>\n<h3 id=\"工厂模式\"><a class=\"anchor\" href=\"#工厂模式\">#</a> 工厂模式</h3>\n<h4 id=\"简单工厂\"><a class=\"anchor\" href=\"#简单工厂\">#</a> 简单工厂</h4>\n<p><img data-src=\"https://img-blog.csdn.net/20180609213904662\" alt=\"img\" /></p>\n<h5 id=\"各组成部分的功能\"><a class=\"anchor\" href=\"#各组成部分的功能\">#</a> 各组成部分的功能</h5>\n<ol>\n<li>Creater 核心，包含应用程序锁需要的业务逻辑。同时负责委托工厂生产对象</li>\n<li>Product 接口 / 抽象类 是具体子类的超类 / 接口</li>\n<li>ConcreteProduct 实现 Product 接口 / 继承 Product 抽象类</li>\n</ol>\n<h5 id=\"优点-2\"><a class=\"anchor\" href=\"#优点-2\">#</a> 优点</h5>\n<ol>\n<li>\n<p>工厂方法包含从一个类的结构中选择初始类的业务逻辑</p>\n</li>\n<li>\n<p>客户类不直接创建产品类的对象，值作为对象的消费者</p>\n</li>\n<li>\n<p>实现了责任分离</p>\n</li>\n<li>\n<p>如果有新产品子类加入，不必修改客户类 (前提是客户类不用新产品)</p>\n</li>\n<li>\n<p>因为 1, 所以客户类不需要繁杂的逻辑判断</p>\n</li>\n</ol>\n<h5 id=\"缺点\"><a class=\"anchor\" href=\"#缺点\">#</a> 缺点</h5>\n<ol>\n<li>增加产品类时，要修改工厂类</li>\n<li>因为工厂类的工厂方法是静态的，所以工厂类中的方法不能被继承，因此只能承载一个单独的类群，而不是一个有多层结构的类</li>\n</ol>\n<h6 id=\"为了解决简单工厂的缺点-工厂方法\"><a class=\"anchor\" href=\"#为了解决简单工厂的缺点-工厂方法\">#</a> 为了解决简单工厂的缺点 --- 工厂方法</h6>\n<h4 id=\"工厂方法\"><a class=\"anchor\" href=\"#工厂方法\">#</a> 工厂方法</h4>\n<h6 id=\"核心思想将简单工厂中单一的工厂类改写成一个层次类\"><a class=\"anchor\" href=\"#核心思想将简单工厂中单一的工厂类改写成一个层次类\">#</a> 核心思想：将简单工厂中单一的工厂类改写成一个层次类</h6>\n<p>&lt;img src=&quot;C:\\Users\\www13\\AppData\\Roaming\\Typora\\typora-user-images\\image-20211114142203065.png&quot; alt=&quot;image-20211114142203065&quot; style=&quot;zoom: 50%;&quot; /&gt;</p>\n<h5 id=\"类图解释\"><a class=\"anchor\" href=\"#类图解释\">#</a> 类图解释</h5>\n<p>Creater: 接口，含有一个 factory 方法，然后可以用和产品类相同的结构产生创建者类结构，其中包含 CreaterA 和 CreaterB</p>\n<p>CreaterA/B: 负责创建对应的 ProductA 和 ProductB 的对象</p>\n<h5 id=\"和简单工厂的相同之处\"><a class=\"anchor\" href=\"#和简单工厂的相同之处\">#</a> 和简单工厂的相同之处</h5>\n<ol>\n<li>方法模式一样，工厂方法也返回一个属于父类 Product 类型的对象，客户不必知道返回对象的具体类型</li>\n</ol>\n<h5 id=\"和简单工厂的区别\"><a class=\"anchor\" href=\"#和简单工厂的区别\">#</a> 和简单工厂的区别</h5>\n<ol>\n<li>中心不同。工厂方法的中心是抽象工厂类 / 接口，而简单工厂方法的中心是一个实的工厂类<br />\n在简单工厂的工厂方法是静态的，而工厂方法是动态的</li>\n<li>简单工厂方法不支持开闭原则。而工厂方法支持.<br />\n 简单工厂增加产品类：在工厂类中也应增加条件语句<br />\n工厂方法增加产品类：在 Product 类的结构体重增加一个实体，在工厂类层次结构体中增加一个相应的能产生该新产品对象的实类</li>\n<li>工厂方法工厂类不必包含创建对象的逻辑判断</li>\n</ol>\n<h5 id=\"使用工厂方法的情况\"><a class=\"anchor\" href=\"#使用工厂方法的情况\">#</a> 使用工厂方法的情况</h5>\n<ol>\n<li>创建某些类的对象的逻辑比较复杂，并且有很多条件分支</li>\n<li>一个类不能准确预知它要创建一个层次类中哪个子类的对象</li>\n<li>一个类使用子类决定要创建的对象</li>\n<li>需要封装创建类的对象的逻辑，使这些逻辑局部化</li>\n</ol>\n<h4 id=\"抽象工厂模式\"><a class=\"anchor\" href=\"#抽象工厂模式\">#</a> 抽象工厂模式</h4>\n<h5 id=\"类图\"><a class=\"anchor\" href=\"#类图\">#</a> 类图</h5>\n<p><img data-src=\"G:%5CApp%5CQQ%5CQQ_Chat_File%5C1335894629%5CFileRecv%5CMobileFile%5CIMG_20211114_144057_edit_205109997971306.jpg\" alt=\"IMG_20211114_144057_edit_205109997971306\" /></p>\n<h5 id=\"抽象工厂模式中包含\"><a class=\"anchor\" href=\"#抽象工厂模式中包含\">#</a> 抽象工厂模式中包含</h5>\n<ol>\n<li>一系列互相有关联的产品类，(有相同的结构)</li>\n<li>一系列实的工厂类，实现由抽象工厂提供的接口。他们各自生产一组相关的产品类对象</li>\n</ol>\n<h6 id=\"当客户对象要从一个相关的产品组中创建一个对象而没有必要知道到底创建哪个对象时使用抽象工厂\"><a class=\"anchor\" href=\"#当客户对象要从一个相关的产品组中创建一个对象而没有必要知道到底创建哪个对象时使用抽象工厂\">#</a> 当客户对象要从一个相关的产品组中创建一个对象，而没有必要知道到底创建哪个对象时使用抽象工厂</h6>\n<h6 id=\"抽象工厂方法不符合开闭原则-增加一个新产品层次类则必须在每个工厂实类中增加方法\"><a class=\"anchor\" href=\"#抽象工厂方法不符合开闭原则-增加一个新产品层次类则必须在每个工厂实类中增加方法\">#</a> 抽象工厂方法不符合开闭原则 -- 增加一个新产品层次类，则必须在每个工厂实类中增加方法</h6>\n<h3 id=\"装饰者模式\"><a class=\"anchor\" href=\"#装饰者模式\">#</a> 装饰者模式</h3>\n<p>提供一个比继承更加灵活的方案</p>\n<p>类图</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211114145247937.png\" alt=\"image-20211114145247937\" /></p>\n<h3 id=\"访问者模式\"><a class=\"anchor\" href=\"#访问者模式\">#</a> 访问者模式</h3>\n<h6 id=\"解决问题-对一个已经完成设计与diamante编写的类的层次结构进行功能修改或增加新功能\"><a class=\"anchor\" href=\"#解决问题-对一个已经完成设计与diamante编写的类的层次结构进行功能修改或增加新功能\">#</a> 解决问题 -- 对一个已经完成设计与 diamante 编写的类的层次结构进行功能修改或增加新功能</h6>\n<p><img data-src=\"G:%5CApp%5CQQ%5CQQ_Chat_File%5C1335894629%5CFileRecv%5CMobileFile%5CIMG_20211114_150707.jpg\" alt=\"IMG_20211114_150707\" /></p>\n<h4 id=\"类图解释-2\"><a class=\"anchor\" href=\"#类图解释-2\">#</a> 类图解释</h4>\n<ol>\n<li>\n<p>VIsitor: 为每个 element 的类声明了一个访问操作</p>\n</li>\n<li>\n<p>concreteVisitor: 实现 Visitor 声明的运算</p>\n</li>\n<li>\n<p>Element: 定义了一些基本的方法，包含提供基本数据的方法.<br />\n 重要的是，它的子类必须定义一个接收者方法，为被访问者对象和访问者对象之间提供接口</p>\n</li>\n<li>\n<p>ConcreteElement : 具体的 Element 的子类</p>\n</li>\n<li>\n<p>ObjectStructure 提供一个高层接口，允许访问者访问 Element 的子类., 提供一个访问列表</p>\n</li>\n</ol>\n<h4 id=\"使用访问者模式的情况\"><a class=\"anchor\" href=\"#使用访问者模式的情况\">#</a> 使用访问者模式的情况</h4>\n<ol>\n<li>当一个对象的结构中，包含有多种类型的具有不同接口的对象，且用户要在这些对象上进行依赖于具体的类的运算</li>\n<li>当有多个不同的并且互不相关的运算将作用域这些对象上，且用户不希望这些运算混淆这些类时</li>\n<li>当对象的数据类型很少改变，但需要经常改变操作或增加新操作的情况下.</li>\n</ol>\n<h2 id=\"状态模式\"><a class=\"anchor\" href=\"#状态模式\">#</a> 状态模式</h2>\n<p>将不同状态下的行为封装在不同的类中，每个类代表一个状态</p>\n<p>使用场景:</p>\n<p>当一个类依赖于状态，那么程序员在描述该对象的类中通常会使用很多条件语句，<br />\n 这时，使用状态模式可以有效消除条件语句并使得状态转换非常清楚</p>\n<h6 id=\"gang-of-four的定义\"><a class=\"anchor\" href=\"#gang-of-four的定义\">#</a> GANG OF FOUR 的定义:</h6>\n<h6 id=\"允许一个对象在其内部状态改变时改变其行为这个对象看起来似乎修改了它的类\"><a class=\"anchor\" href=\"#允许一个对象在其内部状态改变时改变其行为这个对象看起来似乎修改了它的类\">#</a> 允许一个对象在其内部状态改变时，改变其行为。这个对象看起来似乎修改了它的类</h6>\n<h6 id=\"类图-2\"><a class=\"anchor\" href=\"#类图-2\">#</a> 类图</h6>\n<p><img data-src=\"G:%5CApp%5CQQ%5CQQ_Chat_File%5C1335894629%5CFileRecv%5CMobileFile%5CIMG_20211121_185300.jpg\" alt=\"IMG_20211121_185300\" /></p>\n<p>各组件描述:</p>\n<p>Context: 定义了和客户程序的接口，它保持了一个 ConcreteState 的代表现在状态的<strong>实例</strong></p>\n<p>State: 状态接口，子类封装各个状态下行为<br />\n ConcreteState:State 的子类</p>\n<p>使用状态模式的情况</p>\n<ol>\n<li>对象的行为依赖于状态，对象再运行时改变状态</li>\n<li>操作有大量依赖于状态的条件语句</li>\n</ol>\n<p>优点</p>\n<ol>\n<li>容易添加新的状态 (因为封装在子类),</li>\n<li>状态迁移很明确</li>\n</ol>\n<h2 id=\"桥接模式\"><a class=\"anchor\" href=\"#桥接模式\">#</a> 桥接模式</h2>\n<h6 id=\"将对象的继承转为对象的组合\"><a class=\"anchor\" href=\"#将对象的继承转为对象的组合\">#</a> 将对象的继承转为对象的组合</h6>\n<h5 id=\"将一个软件设计的抽象部分和实现部分分离使它们都可以独立地变化\"><a class=\"anchor\" href=\"#将一个软件设计的抽象部分和实现部分分离使它们都可以独立地变化\">#</a> 将一个软件设计的抽象部分和实现部分分离，使它们都可以独立地变化.</h5>\n<p>类图<img data-src=\"G:%5CApp%5CQQ%5CQQ_Chat_File%5C1335894629%5CFileRecv%5CMobileFile%5CIMG_20211121_192040.jpg\" alt=\"IMG_20211121_192040\" /></p>\n<p>各部分解释</p>\n<ol>\n<li>Abstraction 接口，定义抽象部分的接口，为吃 Implementor 对象的一个参考</li>\n<li>RefinedAbstraction, 继承或者实现 Abstraction</li>\n<li>Implementor: 定义 Implementation 类的接口，接口形式可以不和 Abstraction 界面严格对应</li>\n<li>ConcreteImplementor: 实现 Implementor 接口</li>\n</ol>\n<p>优点</p>\n<ol>\n<li>分离接口和实现部分，</li>\n<li>提高了可扩展性</li>\n<li>实现了细节对客户的透明</li>\n</ol>\n<h2 id=\"适配器模式\"><a class=\"anchor\" href=\"#适配器模式\">#</a> 适配器模式</h2>\n<p>目的：解决接口不一致</p>\n<p>分为类适配器模式和对象适配器模式</p>\n<p>类图</p>\n<p><img data-src=\"G:%5CApp%5CQQ%5CQQ_Chat_File%5C1335894629%5CFileRecv%5CMobileFile%5CIMG_20211121_193024_edit_222571278535829.jpg\" alt=\"IMG_20211121_193024_edit_222571278535829\" /></p>\n<p>类适配器：写一个 target 接口声明所有需要的方法，写一个 adaptor 类继承 adapee 类，并且实现接口 target</p>\n<p>对象适配器：写一个 target 接口声明所有需要的方法，采用聚合的方法来实现 adaptee 类中的方法</p>\n<p>使用适配器模式的情况</p>\n<ol>\n<li>想要使用现有的类，但现有类的接口不符合需求</li>\n<li>当需要通过创建一个可服用的类，是的本来接口不相容且无关的类结合在一起工作时</li>\n<li>在设计中需要改变多个子类接口，在作用相同但名称不同的类或方法之间进行适配时.</li>\n</ol>\n<h3 id=\"mvc\"><a class=\"anchor\" href=\"#mvc\">#</a> MVC</h3>\n<ul>\n<li>视图：管理作为位图展示到屏幕上的图形和文字输出；</li>\n<li>控制器：翻译用户的输入并依照用户的输入操作模型和视图；</li>\n<li>模型：管理应用的行为和数据，响应数据请求（经常来自视图）和更新状态的指令（经常来自控制器）；</li>\n</ul>\n<p>如果用户通过一个 View 的 Controller 改变了 Model, 所有其他的 View 都必须反映出该改变.</p>\n<p>当数据发生变化的时候，Model 负责通知所有的 View, 告诉他们数据已经改变了</p>\n",
            "tags": [
                "大三",
                "软件",
                "软件体系结构"
            ]
        },
        {
            "id": "http://example.com/2021/12/07/android%E4%B8%8E%E8%85%BE%E8%AE%AF%E4%BA%91mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5-windows/",
            "url": "http://example.com/2021/12/07/android%E4%B8%8E%E8%85%BE%E8%AE%AF%E4%BA%91mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5-windows/",
            "title": "未继续_android与腾讯云mysql数据库连接_windows",
            "date_published": "2021-12-07T13:54:50.000Z",
            "content_html": "<p>第一步</p>\n<blockquote>\n<p>购买一个腾讯云服务</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/u7yYjh39kGZfp8X.png\" alt=\"image-20211207215535055\" /></p>\n<p>然后初始化 (请记住密码)</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/UlmbJ9cSR8NHkAe.png\" alt=\"image-20211207221439709\" /></p>\n<p>开启外网地址 (不然怎么连</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/Tijutps6K3ZB1wg.png\" alt=\"image-20211207222027892\" /></p>\n</blockquote>\n<p>第二步，下载 androidstudio</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/aAXyWbjZR6c2uht.png\" alt=\"image-20211207215837466\" /></p>\n<p>第三步，下载对应数据库版本的 jdbc, 我的腾讯云是 mysql8</p>\n<blockquote>\n<p>jdbc 位置是</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubXlzcWwuY29tL3Byb2R1Y3RzL2Nvbm5lY3Rvci8=\">MySQL :: MySQL Connectors</span></p>\n<p>打开之后长这样，下载 JDBC</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/UnWrX4BHD5PFTpR.png\" alt=\"image-20211207215936667\" /></p>\n<p>这儿选 platform independent, 然后点第二个下载</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211207220401699.png\" alt=\"image-20211207220401699\" /></p>\n<p>解压之后能看到这个东西</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211207220521395.png\" alt=\"image-20211207220521395\" /></p>\n<ol start=\"4\">\n<li>把上面那玩意引入 android</li>\n</ol>\n<p>首先在 project 底下的 app 文件夹的子目录找到 libs 文件夹，把那个 jdbc 的 jar 包拖进去</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/Qupag1AD3JFYfB6.png\" alt=\"image-20211207221048176\" /></p>\n<p>如果没有，把左上角的这个调成 ProjectFiles 看看，还没有就自己新建一个</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/kJ6CrM37XSUsbQI.png\" alt=\"image-20211207221113280\" /></p>\n<p>右键它，选择 add as library</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211207221300723.png\" alt=\"image-20211207221300723\" /></p>\n</blockquote>\n",
            "tags": [
                "大三",
                "失败",
                "android"
            ]
        },
        {
            "id": "http://example.com/2021/12/07/%E5%A4%96%E8%AE%BE/",
            "url": "http://example.com/2021/12/07/%E5%A4%96%E8%AE%BE/",
            "title": "21/12/7 设备管理",
            "date_published": "2021-12-07T00:43:00.000Z",
            "content_html": "<h1 id=\"设备管理\"><a class=\"anchor\" href=\"#设备管理\">#</a> 设备管理</h1>\n<h2 id=\"1-控制器\"><a class=\"anchor\" href=\"#1-控制器\">#</a> 1. 控制器</h2>\n<h6 id=\"控制器的任务是在外设与内存之间完成比特流与字节块之间的转换\"><a class=\"anchor\" href=\"#控制器的任务是在外设与内存之间完成比特流与字节块之间的转换\">#</a> 控制器的任务是在外设与内存之间完成比特流与字节块之间的转换</h6>\n<h3 id=\"11寄存器\"><a class=\"anchor\" href=\"#11寄存器\">#</a> 1.1 寄存器</h3>\n<p>每个控制器有几个寄存器，操作系统可以往里写东西</p>\n<h3 id=\"12数据缓冲区\"><a class=\"anchor\" href=\"#12数据缓冲区\">#</a> 1.2 数据缓冲区</h3>\n<p>有些控制器上有，用于大数据传输</p>\n<h4 id=\"121磁盘控制器\"><a class=\"anchor\" href=\"#121磁盘控制器\">#</a> 1.2.1 磁盘控制器</h4>\n<p>将位流组装为字节存入缓冲区中，形成字节为单位的块</p>\n<h2 id=\"2控制方式\"><a class=\"anchor\" href=\"#2控制方式\">#</a> 2. 控制方式</h2>\n<h4 id=\"21-程序直接控制\"><a class=\"anchor\" href=\"#21-程序直接控制\">#</a> 2.1 程序直接控制</h4>\n<p>cpu 控制全过程</p>\n<p>效率低下 (CPU 一直在等)</p>\n<h4 id=\"22中断控制\"><a class=\"anchor\" href=\"#22中断控制\">#</a> 2.2 中断控制</h4>\n<p>cpu 发送指令，去干别的，等 io 设备准备好，利用中断通知 cpu</p>\n<h4 id=\"23-dma方式适合高速大量的外设\"><a class=\"anchor\" href=\"#23-dma方式适合高速大量的外设\">#</a> 2.3 DMA 方式 (适合高速大量的外设)</h4>\n<p>cpu 启动指令 -&gt;DMA 控制器 -&gt;(data)-&gt; 启动外设</p>\n<p>整个数据的传输都是在 DMA 控制下进行的</p>\n<h4 id=\"24通道控制方式\"><a class=\"anchor\" href=\"#24通道控制方式\">#</a> 2.4 通道控制方式</h4>\n<p>cpu 连接多个通道，通道连接多个控制器，再连接外部设备</p>\n<p>imgtest</p>\n<h2 id=\"3设备io子系统\"><a class=\"anchor\" href=\"#3设备io子系统\">#</a> 3. 设备 I/o 子系统</h2>\n<p>申请设备</p>\n<p>将数据写入设备</p>\n<p>从设备读取数据</p>\n<p>释放设备</p>\n<h4 id=\"分时式共享使用设备\"><a class=\"anchor\" href=\"#分时式共享使用设备\">#</a> 分时式共享使用设备</h4>\n<p>以一次 IO 为单位分时使用设备</p>\n<h4 id=\"spooling方式使用外设\"><a class=\"anchor\" href=\"#spooling方式使用外设\">#</a> SPOOLING 方式使用外设</h4>\n<p>利用磁盘上的输入输出并模拟高速外设</p>\n<h3 id=\"io的组成\"><a class=\"anchor\" href=\"#io的组成\">#</a> IO 的组成</h3>\n<p>I.O 交通管制程序</p>\n<p>调度程序</p>\n<p>设备处理程序</p>\n<h6 id=\"基本思想分层构建较低层为较高层服务使较高层独立于硬件为用户提供统一接口\"><a class=\"anchor\" href=\"#基本思想分层构建较低层为较高层服务使较高层独立于硬件为用户提供统一接口\">#</a> 基本思想：分层构建，较低层为较高层服务，使较高层独立于硬件，为用户提供统一接口</h6>\n<h4 id=\"io设计目标\"><a class=\"anchor\" href=\"#io设计目标\">#</a> I/O 设计目标</h4>\n<blockquote>\n<p><strong>设备独立性</strong> -- 使软硬件相对独立，给上层软件更好的可移植性</p>\n<p><strong>设备统一命名</strong> - 每种设备都是有名称的，如何命名以方便系统管理和用户使用是一个重要的问题</p>\n<p>采取预先设计的，统一的逻辑名称</p>\n<p><strong>出错处理</strong>：数据尽可能在接近硬件层处理，仅当低层无能为力时，才将错误上交</p>\n<p><strong>缓冲技术</strong>：设法使数据的到达率和离去率匹配，提高系统的吞吐量</p>\n<p><strong>设备的分配</strong>：共享设备和独占设备的分配问题</p>\n</blockquote>\n",
            "tags": [
                "大三",
                "操作系统",
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2021/12/07/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/",
            "url": "http://example.com/2021/12/07/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/",
            "title": "21/12/7 存储管理-操作系统",
            "date_published": "2021-12-07T00:43:00.000Z",
            "content_html": "<h1 id=\"存储管理\"><a class=\"anchor\" href=\"#存储管理\">#</a> 存储管理</h1>\n<h4 id=\"地址访问保护机制\"><a class=\"anchor\" href=\"#地址访问保护机制\">#</a> 地址访问保护机制</h4>\n<ol>\n<li>\n<h5 id=\"上下界寄存器和地址检查机制\"><a class=\"anchor\" href=\"#上下界寄存器和地址检查机制\">#</a> 上下界寄存器和地址检查机制</h5>\n</li>\n</ol>\n<p>​\t\t作业拥有上下界，执行访存指令时，判断是否越界</p>\n<p>​\t\t要求：作业程序是<strong>绝对地址</strong>或<strong>静态可浮动</strong></p>\n<h5 id=\"2-基址寄存器-长度寄存器和动态地址转换机制\"><a class=\"anchor\" href=\"#2-基址寄存器-长度寄存器和动态地址转换机制\">#</a> 2. 基址寄存器、长度寄存器和动态地址转换机制</h5>\n<p>​\t\t<strong>当作业被调度运行时，将作业所占内存基址及长度送基址、长度寄存器，在用户态每次执行访存指令时，先看访问地址是否小于长度，然后 + 基址进行访存。用户程序代码是</strong>动态浮动的</p>\n<h2 id=\"可变分区\"><a class=\"anchor\" href=\"#可变分区\">#</a> 可变分区</h2>\n<h6 id=\"思想预先不划分内存当作业需要时向系统申请系统从其中挖出一块给该作业\"><a class=\"anchor\" href=\"#思想预先不划分内存当作业需要时向系统申请系统从其中挖出一块给该作业\">#</a> 思想:<strong> 预先不划分内存，当作业需要时向系统申请，系统从其中挖出一块给该作业</strong></h6>\n<p>Q:&lt;u&gt; 空闲区域如何管理 &lt;/u&gt;?</p>\n<h3 id=\"多道连续可变分区法\"><a class=\"anchor\" href=\"#多道连续可变分区法\">#</a> <strong>多道连续可变分区法</strong></h3>\n<h5 id=\"特点多道连续不固定划分内存\"><a class=\"anchor\" href=\"#特点多道连续不固定划分内存\">#</a> 特点：多道，连续，不固定划分内存</h5>\n<h5 id=\"管理方法\"><a class=\"anchor\" href=\"#管理方法\">#</a> 管理方法</h5>\n<p><strong>系统设置一个空闲块队列，初始状态时队列中只有一个连续的空闲块。作业到达后，以</strong>某种策略分配空间。作业撤离时，将释放的空间加入空闲队列。</p>\n<h5 id=\"释放方法\"><a class=\"anchor\" href=\"#释放方法\">#</a> 释放方法</h5>\n<p>相邻合并，否则插入</p>\n<h5 id=\"例一\"><a class=\"anchor\" href=\"#例一\">#</a> 例一</h5>\n<p>进入执行顺序：(1,2,3)-&gt;(4)-&gt;(5)</p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112134311512.png\" alt=\"image-20211112134311512\" /></p>\n<h4 id=\"分配方法\"><a class=\"anchor\" href=\"#分配方法\">#</a> 分配方法</h4>\n<ol>\n<li>首次满足法 从头到尾找，找到的第一个满足它的空间就给它</li>\n<li>最佳满足法 从队列中找一个最接近的空闲队列给它</li>\n<li>最大满足法 每次找最大的空间给最新创建的进程</li>\n</ol>\n<h4 id=\"可用空间管理\"><a class=\"anchor\" href=\"#可用空间管理\">#</a> 可用空间管理</h4>\n<h5 id=\"紧致机制-将已有的进程挪到一起腾出大块的连续空间\"><a class=\"anchor\" href=\"#紧致机制-将已有的进程挪到一起腾出大块的连续空间\">#</a> 紧致机制 -- 将已有的进程挪到一起，腾出大块的连续空间</h5>\n<h5 id=\"可再定位式分区-浮动分区分配\"><a class=\"anchor\" href=\"#可再定位式分区-浮动分区分配\">#</a> 可再定位式分区 -- 浮动分区分配</h5>\n<h2 id=\"页式存储管理\"><a class=\"anchor\" href=\"#页式存储管理\">#</a> 页式存储管理</h2>\n<h6 id=\"解决作业不连续存放的问题\"><a class=\"anchor\" href=\"#解决作业不连续存放的问题\">#</a> 解决作业不连续存放的问题</h6>\n<p><strong>特点：</strong> <strong>作业</strong> <strong>(进程)</strong> <strong>分成页面，内存也划分成页面，将作业</strong> **(进程 **) <strong>页面不连续地分布到内存页面</strong></p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112140406228.png\" alt=\"image-20211112140406228\" /></p>\n<h5 id=\"基本原理\"><a class=\"anchor\" href=\"#基本原理\">#</a> 基本原理</h5>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112140441074.png\" alt=\"image-20211112140441074\" /></p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112141149243.png\" alt=\"image-20211112141149243\" /></p>\n<p><strong>分页逻辑地址</strong> <strong>= P (页号).d (</strong>  <strong>页内位移</strong> ** ) **</p>\n<p><strong>分页物理地址</strong> <strong>= f(<strong><strong>页帧号</strong></strong>).d (<strong><strong>同上</strong></strong>)</strong></p>\n<p><strong>P =</strong> <strong>线性逻辑地址</strong> <strong>/</strong> <strong>页面大小；</strong></p>\n<p><strong>d =</strong> <strong>线性逻辑地址</strong> **- P***<strong> 页面大小。</strong></p>\n<h6 id=\"为什么是2的k次幂\"><a class=\"anchor\" href=\"#为什么是2的k次幂\">#</a> 为什么是 2 的 k 次幂？</h6>\n<p>将乘除法转成移位运算</p>\n<p><strong>为了取出一个数据，系统需要访问内存几次？</strong>-- 两次：1. 取页表，2. 取数据</p>\n<h3 id=\"快表\"><a class=\"anchor\" href=\"#快表\">#</a> 快表</h3>\n<p>由一组联想寄存器 (TLB, Translation Lookaside Buffer) 组成。</p>\n<p><strong>联想寄存器：一种按内容进行并行查找的快速寄存器，访问速度比主存快得多</strong></p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112142834494.png\" alt=\"image-20211112142834494\" /></p>\n<h6 id=\"使用bitmap数组空闲页帧链管理可用页帧\"><a class=\"anchor\" href=\"#使用bitmap数组空闲页帧链管理可用页帧\">#</a> 使用 bitmap 数组 / 空闲页帧链管理可用页帧</h6>\n<h5 id=\"共享\"><a class=\"anchor\" href=\"#共享\">#</a> 共享</h5>\n<p><strong>通过页表可以使几个逻辑空间指向同一个物理空间，实现程序共享。</strong></p>\n<h5 id=\"越界保护\"><a class=\"anchor\" href=\"#越界保护\">#</a> 越界保护</h5>\n<p>设置页表长度寄存器，查页表前，检查页号是否越界</p>\n<h5 id=\"访问保护\"><a class=\"anchor\" href=\"#访问保护\">#</a> 访问保护</h5>\n<p><strong>在每个页表项中增设一存储保护域，用于说明对该页的访问权限，每一个对该页存储的访问都首先要比照是否满足该页访问权限的说明，满足则访问，否则报异常。</strong></p>\n<h3 id=\"ø优点\"><a class=\"anchor\" href=\"#ø优点\">#</a> Ø<strong> 优点</strong></h3>\n<p>ü<strong> 没有外碎片，每个内碎片不超过页大小。</strong></p>\n<p>ü<strong> 程序不必连续存放。</strong></p>\n<h3 id=\"ø主要缺点\"><a class=\"anchor\" href=\"#ø主要缺点\">#</a> Ø<strong> 主要缺点：</strong></h3>\n<p>ü<strong> 程序要一次全部装入内存才能执行。</strong></p>\n<p>ü<strong> 采用动态地址变换机构会增加计算机的成本和降低处理机的速度。</strong></p>\n<p>ü<strong> 各种数据结构</strong> (页表，空闲页表) 要占用一定的内存空间，而且系统要花费一定的时间来建立和管理这些表格。</p>\n<p>ü<strong> 依然存在内碎片。</strong></p>\n<h2 id=\"段式存储管理\"><a class=\"anchor\" href=\"#段式存储管理\">#</a> 段式存储管理</h2>\n<h4 id=\"特点按作业的自然段将其逻辑空间分成若干段作业以段为单位分配内存\"><a class=\"anchor\" href=\"#特点按作业的自然段将其逻辑空间分成若干段作业以段为单位分配内存\">#</a> 特点:<strong> 按作业的自然段将其逻辑空间分成若干段，作业以段为单位分配内存。</strong></h4>\n<p>Ø<strong> 用户作业逻辑空间为二维空间，由若干自然段组成。</strong></p>\n<p>Ø 逻辑地址：段号段内偏移，记作 S,d。编译及装配时把所有地址记成 (S,d) 的形式。</p>\n<p>Ø <strong>物理内存空间管理：与多道可变划分法一样，系统以段为单位分配物理内存。</strong></p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112144254340.png\" alt=\"image-20211112144254340\" /></p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211112144844677.png\" alt=\"image-20211112144844677\" /></p>\n<h3 id=\"段页式管理\"><a class=\"anchor\" href=\"#段页式管理\">#</a> 段页式管理</h3>\n<p>特点：<strong>将作业分成若干段，每段用页式管理实现内存分配</strong></p>\n<p><strong>为了获得一条指令或者数据，需要访问内存几次？</strong>--3 次，段表，页表，数据</p>\n<h2 id=\"内存扩充技术\"><a class=\"anchor\" href=\"#内存扩充技术\">#</a> 内存扩充技术</h2>\n<h6 id=\"借助大容量的辅存实现内存的扩充\"><a class=\"anchor\" href=\"#借助大容量的辅存实现内存的扩充\">#</a> 借助大容量的辅存实现内存的扩充</h6>\n<h3 id=\"覆盖技术\"><a class=\"anchor\" href=\"#覆盖技术\">#</a> 覆盖技术</h3>\n<p>** 将用户空间划分成一个固定区和多个覆盖区。主程序放固定区，依次调用的子程序则放在同一个覆盖区。**<strong> 操作系统提供覆盖系统调用函数，由用户编程序显式调用</strong></p>\n<p>相当于时间换空间</p>\n<h3 id=\"交换技术\"><a class=\"anchor\" href=\"#交换技术\">#</a> 交换技术</h3>\n<p>将处于等待状态 (等 I/O 结束) 或就绪 (等 CPU) 状态的作业从主存换出到辅存，把将要执行的进程移入主存。</p>\n<p>优点:</p>\n<p>提高并发性</p>\n<p>缺点:</p>\n<p>换入换出增加处理机开销</p>\n<p>程序换入时存在重定位问题</p>\n<h6 id=\"和覆盖技术对比\"><a class=\"anchor\" href=\"#和覆盖技术对比\">#</a> 和覆盖技术对比</h6>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116081410386.png\" alt=\"image-20211116081410386\" /></p>\n<h3 id=\"虚拟存储技术\"><a class=\"anchor\" href=\"#虚拟存储技术\">#</a> 虚拟存储技术</h3>\n<h4 id=\"基础\"><a class=\"anchor\" href=\"#基础\">#</a> 基础</h4>\n<p>程序中不是每一条指令都会在程序的一次运行过程中执行到。<br />\n错误处理子程序<br />\n条件语句 (if...else...)<br />\n 程序中有的指令可能只执行一次<br />\n程序的初始化部分<br />\n程序执行的局部性原理：在一段时间内，作业一般不会执行到所有程序的指令，也不会存取绝大部分数据，执行的代码和要存取的数据往往集中在某些区域中 (例如一个循环、一个数组)。</p>\n<h5 id=\"目的提供用户进程一个巨大的虚拟存储空间\"><a class=\"anchor\" href=\"#目的提供用户进程一个巨大的虚拟存储空间\">#</a> 目的：提供用户进程一个巨大的虚拟存储空间</h5>\n<h5 id=\"手段利用外存磁盘实现此虚空间\"><a class=\"anchor\" href=\"#手段利用外存磁盘实现此虚空间\">#</a> 手段：利用外存 (磁盘) 实现此虚空间。</h5>\n<h4 id=\"基本思想\"><a class=\"anchor\" href=\"#基本思想\">#</a> <strong>基本思想</strong></h4>\n<p>系统为进程提供一个比物理内存大得多的虚拟存储空间，虚拟空间大小不受物理内存大小的限制。</p>\n<p>虚拟空间的容量由系统的有效地址长度决定。假设地址长度为 32，按字节寻址，则虚拟存储空间大小为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^{32}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span> 个字节。</p>\n<h4 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> <strong>原理</strong></h4>\n<p>在程序装入时，不必一次将其全部读入到内存，而只需将<strong>当前需要执行的某些区域</strong>读入到内存，然后程序开始执行。在程序执行过程中，如果<strong>需执行的指令或访问的数据尚未在内存</strong>，则由处理器<strong>通知操作系统将相应的区域调入内存</strong>，然后继续执行。</p>\n<h4 id=\"分类\"><a class=\"anchor\" href=\"#分类\">#</a> 分类</h4>\n<h5 id=\"虚拟页式\"><a class=\"anchor\" href=\"#虚拟页式\">#</a> 虚拟页式</h5>\n<h6 id=\"页表增加外存标识位和外存地址项\"><a class=\"anchor\" href=\"#页表增加外存标识位和外存地址项\">#</a> 页表增加外存标识位和外存地址项</h6>\n<p><strong>当内存中没有空闲页面时，如果还要调入一个新页，如何处理？</strong></p>\n<p>​\t淘汰掉一个内存中的页 (淘汰策略)</p>\n<h6 id=\"交换区\"><a class=\"anchor\" href=\"#交换区\">#</a> 交换区</h6>\n<p>用来回写<strong>数据初始值和初值为 0 的工作区</strong></p>\n<p><strong>页表项结构</strong></p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211116083233571.png\" alt=\"image-20211116083233571\" /></p>\n<p>合法位：置上表示该页在内存。<br />\n修改位：置上表示该页被修改过，在释放或淘汰时应写<br />\n回外存。<br />\n页类型：零页时：表示该页在分配物理页帧时应清 0 页帧<br />\n空间；回写 swap 区页时：表示回写 swap 区。<br />\n保护码：R、W、E 保护说明。<br />\n外存块号：该页所在外存的块号。<br />\n页 帧 号：当合法位置上时代表该页所在内存的页帧号。</p>\n<h6 id=\"缺页处理\"><a class=\"anchor\" href=\"#缺页处理\">#</a> 缺页处理</h6>\n<p>根据发生页故障的虚地址得到页表项；<br />\n申请一个可用的页帧 (根据所采用的替换策略可能需要引起淘汰某一页);<br />\n 检查页类型，若为零页，则将页帧清 0，将页帧号填入页表项的页帧号一栏，置合法位为 1。若非零页，则调用 I/O 子系统将外存块号所指的数据读到可用页帧，将页帧号填入页表项中，合法位置 1，结束。</p>\n<h6 id=\"页淘汰\"><a class=\"anchor\" href=\"#页淘汰\">#</a> 页淘汰</h6>\n<p>查 P 页表项的修改位，若未修改，则清 0 合法位，将页帧送回空闲页帧队列。<br />\n若已修改，则检查类型栏。<br />\n若是零页或回写 swap 区页（代表还没有分配交换区空间），则申请一块 swap 区空间，将 P 的外存块号置上并清除页类型。<br />\n调用 I/0 子系统将页帧上的数据写到外存块号所指的外存空间。清 0 合法位，将页帧送回空闲页帧队列。</p>\n<h3 id=\"页面置换策略\"><a class=\"anchor\" href=\"#页面置换策略\">#</a> 页面置换策略</h3>\n<h6 id=\"出发点-把未来不再使用的或者短时期内较少使用的页面调出\"><a class=\"anchor\" href=\"#出发点-把未来不再使用的或者短时期内较少使用的页面调出\">#</a> 出发点： 把未来不再使用的或者短时期内较少使用的页面调出</h6>\n<p>基本概念</p>\n<h6 id=\"驻留集进程的合法页集合\"><a class=\"anchor\" href=\"#驻留集进程的合法页集合\">#</a> 驻留集：进程的合法页集合</h6>\n<h6 id=\"访问串进程访问虚拟空间的地址踪迹\"><a class=\"anchor\" href=\"#访问串进程访问虚拟空间的地址踪迹\">#</a> 访问串：进程访问虚拟空间的地址踪迹</h6>\n<p>举例：某进程依次访问如下地址，0100，0432，0101，0612，0102，0103，…<br />\n 页式虚存管理以页为基本单位，只需页号即可。设页面大小为 100，上述访问串可简化为 1，4，1，6，1，1，…</p>\n<h4 id=\"驻留集大小固定的局部置换策略\"><a class=\"anchor\" href=\"#驻留集大小固定的局部置换策略\">#</a> 驻留集大小固定的局部置换策略</h4>\n<h5 id=\"fifo先进先出\"><a class=\"anchor\" href=\"#fifo先进先出\">#</a> FIFO（先进先出）</h5>\n<p>替换最早进入的页</p>\n<p>效果奇差</p>\n<p>有<strong> Belady 奇异</strong> <strong>指置换策略不满足随着驻留集的增大，页故障数一定减少的规律。</strong></p>\n<h5 id=\"opt最佳算法\"><a class=\"anchor\" href=\"#opt最佳算法\">#</a> OPT（最佳算法）</h5>\n<p>需要预先知道整个访问串的序列（因此不可实现）</p>\n<p>理论最优</p>\n<h5 id=\"lru最近最少使用\"><a class=\"anchor\" href=\"#lru最近最少使用\">#</a> LRU（最近最少使用）</h5>\n<p><strong>淘汰上次使用距当前最远的页</strong></p>\n<p>栈算法</p>\n<p>LRU 策略中，当驻留集大小为 m 时，S（m，t）中保持着最近使用过的 m 个页帧；当驻留集大小为 m+1 时，S（m+1，t）中保持着最近使用过的 m+1 个页帧。故 S（m，t）属于 S（m+1，t），LRU 策略是栈算法。</p>\n<h5 id=\"clock\"><a class=\"anchor\" href=\"#clock\">#</a> CLOCK</h5>\n<p>基于 LRU 的思想<br />\n硬件在页面被访问时设置页表项中的访问位<br />\n随着表针的移动，淘汰访问位是 0 的页面，或清除页面的访问位。<br />\n实用的页面置换算法</p>\n<h5 id=\"nru最近未使用\"><a class=\"anchor\" href=\"#nru最近未使用\">#</a> NRU (最近未使用)</h5>\n<p>为页帧在页表项中增加一位使用位，硬件每访存一次即将对应页的使用位置 1，操作系统页面管理程序定时将所有使用位清 0。淘汰时任选一个使用位为 0 (表示 OS 清 0 周期内没被使用过）的页。<br />\n操作系统选择淘汰页时，尽量避免选被修改过的页。因此，选择淘汰页次序：</p>\n<h4 id=\"驻留集大小可变的全局置换策略\"><a class=\"anchor\" href=\"#驻留集大小可变的全局置换策略\">#</a> 驻留集大小可变的全局置换策略</h4>\n<h5 id=\"ws\"><a class=\"anchor\" href=\"#ws\">#</a> WS</h5>\n<p>若驻留集中某页有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">△</mi></mrow><annotation encoding=\"application/x-tex\">\\triangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">△</span></span></span></span> 个访问间隔没被访问则将其淘汰 (正是因为这个特性，才是动态的)</p>\n<h6 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现:</h6>\n<p>每一页面设一计数器，每访存一次，将所有其他页计数器 + 1, 所访存的计数器清零，淘汰计数器等于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">△</mi></mrow><annotation encoding=\"application/x-tex\">\\triangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">△</span></span></span></span> 的页面</p>\n<h5 id=\"实际上开销太大没有用\"><a class=\"anchor\" href=\"#实际上开销太大没有用\">#</a> 实际上：开销太大，没有用</h5>\n<h5 id=\"sws\"><a class=\"anchor\" href=\"#sws\">#</a> SWS</h5>\n<p>定时检查计时器，淘汰计时器值大于等于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">△</mi></mrow><annotation encoding=\"application/x-tex\">\\triangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">△</span></span></span></span> 的页面 (当前时钟值 - 页表时钟值)&gt;<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">△</mi></mrow><annotation encoding=\"application/x-tex\">\\triangle</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">△</span></span></span></span> 的页面)</p>\n<h5 id=\"硬件消耗还是很大\"><a class=\"anchor\" href=\"#硬件消耗还是很大\">#</a> 硬件消耗还是很大</h5>\n<h3 id=\"置换策略选择\"><a class=\"anchor\" href=\"#置换策略选择\">#</a> 置换策略选择</h3>\n<p>动态驻留集 sws + 淘汰页数据延迟清除</p>\n<p>设立两个队列：自由链表和修改链表。<br />\n定时做页淘汰（SWS）：淘汰时不立即抹去页中数据，根据页面修改否挂入自由链 / 修改链，修改链过长或自由链过短时，回写页面后改挂到自由链中。<br />\n若 paging in 要用空页时，选自由链的第一页帧，这时页中数据被覆盖。<br />\n若在自由链 / 修改链中的页面再次被访问时，则将该页从链中摘除，使该页又能通过页表项访问到。</p>\n<pre><code class=\"language-chinese\"> 某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为2^10 字节，页表项大小为2字节，逻辑地址结构为：\n\n逻辑地址空间大小为2^16页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少是： ?\n</code></pre>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211119140231647.png\" alt=\"image-20211119140231647\" /></p>\n<p>逻辑空间: 2^16 *2^10 =2^26</p>\n<p>页大小为 2^10 页表项大小为 2, 则一页能写 2^9 个页表项</p>\n<p>共 2^16 逻辑页，故需要 2^7 页</p>\n",
            "tags": [
                "大三",
                "操作系统",
                "操作系统,计算机"
            ]
        },
        {
            "id": "http://example.com/2021/12/07/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/",
            "url": "http://example.com/2021/12/07/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/",
            "title": "21/12/7 文件系统-操作系统",
            "date_published": "2021-12-07T00:43:00.000Z",
            "content_html": "<h1 id=\"文件系统\"><a class=\"anchor\" href=\"#文件系统\">#</a> 文件系统</h1>\n<h2 id=\"文件管理\"><a class=\"anchor\" href=\"#文件管理\">#</a> 文件管理</h2>\n<h3 id=\"文件系统的功能\"><a class=\"anchor\" href=\"#文件系统的功能\">#</a> 文件系统的功能</h3>\n<p>支持文件所占存储介质空间的分配 / 回收<br />\n支持文件相对起始数据的逻辑块定位到外存上的物理块<br />\n支持对文件访问的安全检查<br />\n支持对文件的读写访问</p>\n<h3 id=\"文件的结构\"><a class=\"anchor\" href=\"#文件的结构\">#</a> 文件的结构</h3>\n<h5 id=\"逻辑结构文件组织\"><a class=\"anchor\" href=\"#逻辑结构文件组织\">#</a> 逻辑结构 (<strong>文件组织</strong>):</h5>\n<p>用户看到的文件组织形式，和存储：设备无关</p>\n<p>有结构的记录式文件：由一个以上的记录构成</p>\n<p>无结构的流式文件：文件没有结构，由一串字符流构成</p>\n<h5 id=\"物理结构\"><a class=\"anchor\" href=\"#物理结构\">#</a> 物理结构:</h5>\n<p>外存上存放形式，和存储设备特性有很大关系</p>\n<h5 id=\"文件存储器物理特性\"><a class=\"anchor\" href=\"#文件存储器物理特性\">#</a> 文件存储器物理特性:</h5>\n<p>•<strong>磁带</strong></p>\n<p><strong>顺序访问设备→要求文件顺序存放于带上。</strong></p>\n<p>•<strong>磁盘</strong></p>\n<p><strong>直接（随机）访问设备→文件可顺序、链接式或随机（通过类似页表的索引结构访问）存放于设备上</strong></p>\n<h5 id=\"文件系统重要作用之一\"><a class=\"anchor\" href=\"#文件系统重要作用之一\">#</a> 文件系统重要作用 (之一)</h5>\n<p>在用户逻辑文件和物理文件之间建立映射</p>\n<h4 id=\"文件存取方式\"><a class=\"anchor\" href=\"#文件存取方式\">#</a> 文件存取方式</h4>\n<p><strong>读写文件存储器上的一个物理块的方法</strong></p>\n<p><strong>顺序存取：指对文件中的信息按顺序依次读写</strong></p>\n<p><strong>随机存取法:</strong></p>\n<p>​\t\t<strong>直接存取法：允许用户随意存取文件中任意一个物理记录</strong></p>\n<p>​\t\t<strong>按键存取法：根据文件中各记录的某个数据项内容来存取记录的，这种数据项称之为键</strong></p>\n<h4 id=\"几种常见的物理存储方式\"><a class=\"anchor\" href=\"#几种常见的物理存储方式\">#</a> 几种常见的物理存储方式</h4>\n<h5 id=\"1-连续存储顺序结构\"><a class=\"anchor\" href=\"#1-连续存储顺序结构\">#</a> 1.  连续存储 (顺序结构)</h5>\n<p>它将逻辑上连续的文件信息依次存放在编号连续的物理块上。</p>\n<p>l<strong> 优点：</strong></p>\n<p>–<strong>存储方式简单。</strong></p>\n<p>–<strong>对文件记录进行批量存取时，其存取效率较高。</strong></p>\n<p>–<strong>支持定长记录的直接存取，可以通过计算获得存储位置。</strong></p>\n<p>l<strong> 缺点：</strong></p>\n<p>–<strong>不支持随机查找。如果要随机地查找或修改单个记录，此时系统需要逐个地查找诸记录，性能较差，尤其是当文件较大时情况将更为严重。</strong></p>\n<p>–<strong>存在外部碎片。</strong></p>\n<p>–<strong>不便于记录的增加或删除操作。</strong></p>\n<ol start=\"2\">\n<li>\n<p>–<strong>链接结构</strong></p>\n<p>•<strong>将逻辑上连续的文件信息存放在不连续的物理块上，每个物理块设有一个指针指向下一个物理块。</strong></p>\n<p>l<strong> 优点：</strong></p>\n<p>–<strong>提高了磁盘空间利用率，不存在外部碎片问题。</strong></p>\n<p>–<strong>有利于文件插入和删除，及其动态扩充。</strong></p>\n<p>l<strong> 缺点：</strong></p>\n<p>–<strong>仍然不支持随机查找。</strong></p>\n<p>–<strong>由于存储空间可能不连续，带来更多的寻道次数和寻道时间。</strong></p>\n<p>–<strong>需要牺牲一些空间存放链接指针，同时需要维护这些指针，增加了系统开销。</strong></p>\n<p>–<strong>可靠性问题，如指针出错。</strong></p>\n</li>\n<li>\n<p><strong>索引结构</strong><br />\n将逻辑上连续的文件信息 (记录) 存放在不连续的物理块中，系统为每个文件建立一个专用数据结构 —— 索引表，索引表中存放文件的逻辑块号和物理块号的对应关系</p>\n<ol>\n<li>优点：<br />\n既能顺序存取，又能直接存取。<br />\n满足了文件动态增长、插入删除的要求。<br />\n没有外碎片，外存空间利用率较高。<br />\n缺点<br />\n较多的寻道次数和寻道时间。<br />\n索引表本身需要存储空间，同时对索引表的维护会增加系统开销。</li>\n<li>索引表组织方式\n<ol>\n<li><strong>链接文件方式：将多个索引表块按链接文件的方式串联起来</strong></li>\n<li>多重索引方式：将一个大文件的所有索引表（二级索引) 的地址放在另一个索引表（一级索引) 中。\n<ol>\n<li>多重索引优势\n<ol>\n<li>寻址空间较大，相比于链接文件，会大大减少读取对应物理块所需要的读盘次数 (因为要从文件中读取索引项)</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"文件的目录\"><a class=\"anchor\" href=\"#文件的目录\">#</a> 文件的目录</h3>\n<p>OS 观点：文件包含文件控制块和文件体</p>\n<p>文件控制块（FCB）的主要内容：</p>\n<ul>\n<li>\n<blockquote>\n<p>文件名<br />\n创建者<br />\n文件物理位置信息：如索引表<br />\n创建、修改时间、保存时间<br />\n口令：用于对文件访问进行验证<br />\n操作限制：如读、写、执行权限说明</p>\n</blockquote>\n</li>\n</ul>\n<p>文件目录提供的功能：</p>\n<ul>\n<li>\n<blockquote>\n<p><strong>实现 “按名存取”</strong>。用户只须提供文件名，即可对文件进行存取。这是文件系统向用户提供的最基本的服务。<br />\n<strong>提高对目录的检索速度</strong>。合理地组织目录结构，加快对目录的检索速度，从而加快对文件的存取速度。这是在设计一个大、中型文件系统时，所追求的主要目标。<br />\n<strong>实现文件共享</strong>。在多用户系统中，应允许多个用户共享一个文件，以节省大量的存储空间并方便用户。<br />\n<strong>解决文件重名问题</strong>。系统应允许不同用户对不同文件采用相同的名字，以便于用户按照自己的习惯命名和使用文件。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"文件目录结构\"><a class=\"anchor\" href=\"#文件目录结构\">#</a> 文件目录结构</h4>\n<h5 id=\"l一级目录结构\"><a class=\"anchor\" href=\"#l一级目录结构\">#</a> l<strong> 一级目录结构</strong></h5>\n<ul>\n<li>为外存上的全部文件设立一张平面（flat）的目录表，包含所有文件的 FCB。每建立一个新文件即在目录中增加一个 FCB，每当删除一个文件即抹去对应的 FCB，当要访问一个文件时，先按文件名在目录中找到对应的文件 FCB。<br />\n为了快速查找到文件 FCB，可按文件名进行 Hash，或其它快速查找方式</li>\n<li>优点：简单<br />\n缺点：<br />\n1、查找速度慢<br />\n 2、<strong>不允许重名</strong><br />\n 3、不便于实现文件共享</li>\n</ul>\n<h5 id=\"l二级目录结构\"><a class=\"anchor\" href=\"#l二级目录结构\">#</a> l<strong> 二级目录结构</strong></h5>\n<ul>\n<li>设一个主目录 MFD，为系统的每个用户设用户目录 UFD，用户目录是用户所有文件 FCB 的集合，主目录中存放每个用户目录的用户目录名和 UFD 的索引表等（当我们把 UFD 看作是一个文件时，这个文件的内容是用户所有文件 FCB 集合，MFD 中则包含每个 UFD 文件的 FCB</li>\n<li>路径名<br />\n将用户名与文件名连到一起组成路径名。例如：/songhong/test.c</li>\n</ul>\n<h5 id=\"多级目录树形目录结构\"><a class=\"anchor\" href=\"#多级目录树形目录结构\">#</a> 多级目录 —— 树形目录结构</h5>\n<ul>\n<li>\n<p>树状的多级目录结构<br />\n任何一级目录中的 FCB 既可以描述次一级的子目录，又可以描述一个文件</p>\n</li>\n<li>\n<p>特点:</p>\n</li>\n<li>\n<ul>\n<li>\n<blockquote>\n<p>利于文件分类，从文件路径名可看出文件类别。<br />\n查找文件 FCB 耗费时间，要得到文件 FCB，必须从根查起。<br />\n唯一确定文件的路径名太长，故引入当前目录 概念，提供相对于当前目录的相对路径名可加速文件 FCB 的查找，进程控制块存有当前目录信息</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>访问</p>\n</li>\n<li>\n<blockquote>\n<p>必须指出文件所在路径名：从根目录到该文件的路径上各级目录名的组合。也称为文件全名。<br />\n例如：/usr/lib/man<br />\n 相对路径：设置一个 “当前目录”(也叫 “工作目录”)，此时对于文件的查找是从当前目录中进行的。可以带来两点好处：<br />\n用户使用更加方便<br />\n检索效率更高</p>\n</blockquote>\n</li>\n<li>\n<p>优缺点</p>\n<blockquote>\n<p>l<strong> 树形多级目录结构的优点</strong></p>\n<p>•<strong>提高了检索目录的速度。</strong></p>\n<p>•<strong>较好地解决了重名问题。</strong></p>\n<p>l<strong> 缺点</strong></p>\n<p><strong>不便于用户共享文件</strong></p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"无环图目录结构\"><a class=\"anchor\" href=\"#无环图目录结构\">#</a> 无环图目录结构</h5>\n<h6 id=\"当一个文件副本可以同时属于两个不同目录类别时即同一个文件有二条路径名或多条路径名时出现无环图目录结构\"><a class=\"anchor\" href=\"#当一个文件副本可以同时属于两个不同目录类别时即同一个文件有二条路径名或多条路径名时出现无环图目录结构\">#</a> 当一个文件副本可以同时属于两个不同目录（类别）时，即同一个文件有二条路径名，或多条路径名时出现无环图目录结构。</h6>\n<h6 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点：</h6>\n<p>方便文件共享，分类。<br />\n两个或多个 FCB 的一致性难保证，因此将 FCB 独立存放，引入带文件 / 目录名和 FCB 指针的目录项</p>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/ADfc3PNnYOdbeiH.png\" alt=\"image-20211130092527762\" /></p>\n<h4 id=\"文件共享\"><a class=\"anchor\" href=\"#文件共享\">#</a> 文件共享</h4>\n<ol>\n<li>\n<h5 id=\"硬链接hard-link\"><a class=\"anchor\" href=\"#硬链接hard-link\">#</a> 硬链接 (hard link)</h5>\n<ol>\n<li>指向同一个索引结点</li>\n</ol>\n</li>\n<li>\n<p>符号链接</p>\n<ol>\n<li>建立符号链文件，该文件内容为要访问文件的路径名</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"文件存储器空间布局与管理\"><a class=\"anchor\" href=\"#文件存储器空间布局与管理\">#</a> 文件存储器空间布局与管理</h2>\n<h4 id=\"空闲区表\"><a class=\"anchor\" href=\"#空闲区表\">#</a> 空闲区表</h4>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/H2of5R3Lx7AGNwm.png\" alt=\"image-20211203133204515\" /></p>\n<h4 id=\"位示图\"><a class=\"anchor\" href=\"#位示图\">#</a> 位示图</h4>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/knsUycY9irLAS1G.png\" alt=\"image-20211203133252860\" /></p>\n<p><img data-src=\"C:%5CUsers%5Cwww13%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211203133418295.png\" alt=\"image-20211203133418295\" /></p>\n<h4 id=\"空闲块链\"><a class=\"anchor\" href=\"#空闲块链\">#</a> 空闲块链</h4>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/LH76uxTbrA3FSno.png\" alt=\"image-20211203134255752\" /></p>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/FQnjZpyWuqCd6El.png\" alt=\"image-20211203135715385\" /></p>\n<p><img data-src=\"https://s2.loli.net/2021/12/07/irJzfKHgLs96TBE.png\" alt=\"image-20211203140034820\" /></p>\n",
            "tags": [
                "大三",
                "操作系统",
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2021/12/06/9.1%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A6%82%E8%BF%B0/",
            "url": "http://example.com/2021/12/06/9.1%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A6%82%E8%BF%B0/",
            "title": "21/12/6 Database 数据库完整性概述",
            "date_published": "2021-12-06T14:53:47.000Z",
            "content_html": "<p>9.1 数据库完整性概述</p>\n<p>数据库完整性 -- 数据的正确性，有效性，西安共性</p>\n<p>列级约束</p>\n<p>对属性的数据类型，等的定义</p>\n<p>元祖约束</p>\n<p>元组中各个属性之间的约束关系</p>\n<h4 id=\"实现完整性约束的方法\"><a class=\"anchor\" href=\"#实现完整性约束的方法\">#</a> 实现完整性约束的方法</h4>\n<ol>\n<li>提供定义机制</li>\n<li>提供检查方法</li>\n<li>违约处理</li>\n</ol>\n<h2 id=\"94用户定义的完整性\"><a class=\"anchor\" href=\"#94用户定义的完整性\">#</a> 9.4 用户定义的完整性</h2>\n<h2 id=\"95触发器\"><a class=\"anchor\" href=\"#95触发器\">#</a> 9.5 触发器</h2>\n<p>一类用户定义在关系数据表上的一类由事件驱动的特殊过程，用编程的方法实现复杂的业务规则</p>\n<p>是一种特殊类型的存储过程</p>\n<p>可用触发器完成很多数据库完整性保护的过程</p>\n<ol>\n<li>复杂的业务规则</li>\n<li>比较数据修改前后状态</li>\n</ol>\n<p>SQL:CREATE TRIGER 命令</p>\n<h1 id=\"事务\"><a class=\"anchor\" href=\"#事务\">#</a> 事务</h1>\n<p>原子性：不可分割</p>\n<p>一致性：事务执行结果必须从一个状态转换到另一个状态时保持一致，即若中间出现错误，则将所有操作撤销</p>\n<p>事务应当具有 ACID 性质，<br />\nA 是<strong>原子</strong>性 (atomic)：事务中包含的各项操作必须全部成功执行或者全部不执行。任何一项操作失败，将导致整个事务失败，其他已经执行的任务所作的数据操作都将被撤销，只有所有的操作全部成功，整个事务才算是成功完成。<br />\nC 是<strong>一致性</strong> (consistent)：保证了当事务结束后，系统状态是一致的。那么什么是一致的系统状态？例如，如果银行始终遵循着 &quot;银行账号必须保持正态平衡&quot; 的原则，那么银行系统的状态就是一致的。上面的转账例子中，在取钱的过程中，账户会出现负态平衡，在事务结束之后，系统又回到一致的状态。这样，系统的状态对于客户来说，始终是一致的。<br />\nI 是<strong>隔离</strong>性 (isolated)：使得并发执行的事务，彼此无法看到对方的中间状态。保证了并发执行的事务顺序执行，而不会导致系统状态不一致。<br />\nD 是<strong>持久性</strong> (durable)：保证了事务完成后所作的改动都会被持久化，即使是发生灾难性的失败。可恢复性资源保存了一份事务日志，如果资源发生故障，可以通过日志来将数据重建起来。</p>\n<p>事务应处在下列状态之一</p>\n<p>活动状态</p>\n<p>失败状态：意味着要回滚</p>\n<p>中止状态：数据库已经回滚完毕，恢复到提交前状态</p>\n<p>提交状态：当数据更改完全写入磁盘时，进入提交状态</p>\n<p>10.3.1 事务故障的恢复</p>\n<p>1. 反向扫描日文件日志，查找该事务的更新操作</p>\n<p>2. 对该事务的更新操作执行你操作</p>\n<p>3. 继续反向扫描，直到读到此事务的开始操作</p>\n<p>10.3.2 系统故障恢复</p>\n<p>1.<strong> 正向</strong>扫描日志文件，列出 Redo 队列，Undo 队列</p>\n<h3 id=\"日志\"><a class=\"anchor\" href=\"#日志\">#</a> 日志</h3>\n<p>&lt;u&gt;<strong> 登记两条原则</strong> &lt;/u&gt;</p>\n<p>&lt;u&gt;<strong>1. 登记次序严格按并行事物执行顺序</strong> &lt;/u&gt;</p>\n<p>&lt;u&gt;<strong>2. 先写日志文件，后写数据库</strong> &lt;/u&gt;</p>\n",
            "tags": [
                "大三",
                "数据库",
                "数据库,完整性"
            ]
        }
    ]
}